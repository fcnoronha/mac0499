%!TeX root=../tese.tex
%("dica" para o editor de texto: este arquivo é parte de um documento maior)
% para saber mais: https://tex.stackexchange.com/q/78101/183146

%% ------------------------------------------------------------------------- %%
\chapter{Link-Cut Tree}
\label{cap:link-cut-trees}

Neste capítulo, apresentaremos a estrutura de dados link-cut tree, introduzida por ~\citet{10.1145/800076.802464}. Esta árvore serve como base para as estruturas retroativas apresentadas nos próximos capítulos.

%% ------------------------------------------------------------------------- %%
\section{Ideia}
\label{sec:lct-ideia}

A link-cut tree é uma estrutura de dados que nos permite manter uma floresta de árvores enraizadas com peso nas arestas, onde os nós de cada árvore possuem um número arbitrário de filhos. Ademais, essa estrutura nos fornece o seguinte conjunto de operações:

\begin{itemize}
    \item \texttt{make\_root(u)}: enraíza no vértice $u$ a árvore que o contém.
    \item \texttt{link(u, v, w)}: dado que os vértices $u$ e $v$ estão em árvores separadas, transforma $v$ em raiz de sua árvore e o liga como filho de $u$, colocando peso $w$ na nova aresta criada.
    \item \texttt{cut(u, v)}: retira da árvore a aresta com pontas em $u$ e $v$, efetivamente separando estes vértices e resultando duas novas árvores.
    \item \texttt{is\_connected(u, v)}: retorna \texttt{verdadeiro} caso $u$ e $v$ pertençam á mesma árvore, \texttt{falso} caso contrario.
\end{itemize}

Por último, a link-cut tree possui a capacidade de realizar operações agregadas nos vértices, isto é, consultas acerca de propriedades de uma sub-árvore ou de um caminho entre dois vértices. Em particular, estamos interessados na rotina \texttt{maximum\_edge(u, v)}, que nos informa o peso máximo de uma aresta no caminho entre os vértices $u$ e $v$.

Todas essas operações consomem tempo $\Oh(\log n)$ amortizado, onde $n$ é o número de vértices na floresta.

%% ------------------------------------------------------------------------- %%
\section{Definições}
\label{sec:lct-definicoes}

Primeiramente, precisamos fazer algumas definições acerca da estrutura que vamos estudar.

Chamamos de \emph{árvores representadas} as componentes da floresta armazenada na link-cut tree. Para a representação que a link-cut tree utiliza, internamente dividimos uma árvore representada em caminhos vértice-disjuntos, os chamados \emph{caminhos preferidos}. Todo caminho preferido vai de um vértice a um ancestral deste vértice na árvore representada. Por conveniência, definimos o início de um caminho preferido como o vértice mais profundo contido nele.

Se uma aresta faz parte de um caminho preferido, a chamamos de \emph{aresta preferida}. Ademais, mantemos a propriedade de que um vértice pode ter no máximo uma aresta preferida com a outra ponta em algum de seus filhos. Caso tal aresta exista, ela liga um vértice a seu \emph{filho preferido}.

Finalmente, para cada caminho preferido, elegemos um \emph{vértice identificador}. A manutenção deste vértice será importante para a estrutura auxiliar que utilizaremos para manter os caminhos preferidos, dado que tais vértices serão responsáveis por guardar um ponteiro para o vértice do caminho preferido imediatamente acima do caminho que o contém.

Ademais, para armazenar os pesos das arestas da floresta, a estrutura usada terá nós para vértices e para arestas da floresta. O nó correspondente à aresta $uv$ tem o nó $u$ como seu pai e $v$ como seu único filho.

\begin{center}
    \textbf{TODO}: colocar imagem de uma árvore representada e seus caminhos preferidos.
\end{center}

%% ------------------------------------------------------------------------- %%
% access e como implementa o resto
\section{Operações}
\label{sec:lct-operacoes}

Nessa seção, apresentaremos o código por trás das operações que estamos interessados em implementar na link-cut tree. Em um primeiro momento, assumiremos que já sabemos como implementar alguns métodos que lidam com os caminhos preferidos. Desta forma, a implementação dos métodos abaixo fica reservada para a próxima seção.

\begin{itemize}
    \item \texttt{make\_identifier(u)}: transforma um vértice $u$ em identificador de seu caminho preferido.
    \item \texttt{split(u)}: recebe um nó $u$ e separa o caminho preferido que contém este nó em dois, quebrando a conexão entre $u$ e seu filho preferido, caso exista. Ao final, tanto $u$ quanto o seu filho preferido inicial serão os identificadores de seus caminhos.
    \item \texttt{join(u, v)}: recebe dois nós, $u$ e $v$ --- identificadores de seus caminhos e sendo $v$ um filho de $u$ na árvore representada --- e concatena os respectivos caminhos preferidos, transformando $uv$ em aresta preferida. Com isso, separa $u$ da parte mais profunda de seu caminho preferido inicial, deixando o identificador de tal caminho com um ponteiro para $u$. Ao final da operação, $u$ será o identificador do novo caminho criado.
    \item \texttt{reverse\_path(u)}: recebe $u$, o identificador de um caminho preferido, e inverte a orientação desse caminho, isto é, o fim se transforma no começo e o começo no fim.
    \item \texttt{get\_path\_end\_node(u)}: retorna o vértice menos profundo do caminho preferido de $u$, em outras palavras, o vértice no fim do caminho preferido que contém $u$.
    \item \texttt{get\_parent\_path\_node(u)}: retorna o vértice ma floresta imediatamente acima do fim do caminho preferido que contém $u$; caso tal caminho contenha a raiz da árvore representada, este método retorna \texttt{null}.
    \item \texttt{get\_maximum\_path\_value(u)}:  recebe $u$, o identificador de um caminho preferido, e retorna o maior valor de uma aresta neste caminho.
\end{itemize}

Com tal conjunto de funções, podemos avançar para os métodos da link-cut tree.

\subsection{Rotina Access}
\label{subsection:lct-access}

Uma rotina utilizada por todos os métodos da link-cut tree que vamos implementar é a \texttt{access(u)}, a partir dela conseguimos reorganizar a estrutura interna da árvore representada a nosso favor. Basicamente, a operação \texttt{access(u)} cria um caminho preferido que parte da raiz da árvore representada e vai até $u$. Com isso, todas as arestas preferidas que tinham somente uma das pontas fazendo parte deste novo caminho são destruídas e $u$ termina sem nenhum filho preferido.

Para isso, começamos uma sequência de iterações, que vão crescendo um caminho preferido desde $u$ até que tal caminho contemple a raiz da árvore representada. A cada iteração, fazemos com que uma variável \texttt{current\_root}, que inicialmente corresponde ao vértice $u$, vire o identificador de seu caminho preferido. Além disso, mantemos uma variável \texttt{last}, que corresponde a \texttt{current\_root} da iteração anterior, no início com valor igual a \texttt{null}.

Com estes valores em mãos, podemos ir criando um caminho preferido através de sucessivas concatenações, unindo o caminho que \texttt{current\_root} identifica a parte superior do caminho mantido por \texttt{last}. Ao final dessa concatenação, temos que \texttt{current\_root} é o identificador deste caminho que esta sendo construído, e após guardarmos seu valor em \texttt{last}, podemos prosseguir para o próximo passo, onde \texttt{current\_root} agora corresponde ao no imediatamente em cima do caminho preferido que estamos construindo.

\begin{programruledcaption}{Access\label{lct:access}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},,
    ]
        funcao access(u)
            last := NULL
            current_root := u
            // concatena todos os caminhos preferidos de $u$ até a raiz da árvore representada
            enquanto current_root != NULL
                make_identifier(current_root) // faz virar o identificador de seu caminho preferido 
                join(current_root, last)             // concatena um novo pedaço de caminho preferido ao caminho em que \texttt{last} é identificador
                last := current_root                // \texttt{current\_root} agora é identificador
                current_root := get_parent_path_node(current_root)
            make_identifier(u)
        fim
    \end{lstlisting}
\end{programruledcaption}

Ao final da iteração, colocamos o vértice $u$ como identificador deste novo caminho preferencial, simplificando as operações a seguir.

\subsection{Rotinas Make Root, Link e Cut}
\label{subsection:lct-make-root}

Em seguida, temos a função \texttt{make\_root(u)}, que enraíza em $u$ a árvore representada que o contém. Para isso, criamos um caminho preferencial que vai da raiz da árvore ate $u$, utilizando \texttt{access(u)}. Em seguida, utilizamos a rotina \texttt{reverse\_path(u)}, que inverte a orientação deste caminho preferido recém-criado. Tal inversão coloca $u$ como o vértice de menor profundidade da árvore representada, o que se traduz neste sendo a nova raiz.

\begin{programruledcaption}{Make Root\label{lct:make-root}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},,
    ]
        funcao make_root(u)
            access(u)
            reverse_path(u)
        fim
    \end{lstlisting}
\end{programruledcaption}

Como rotinas que dão nome a nossa estrutura, temos \texttt{link(u, v, w)} e \texttt{cut{u, v}}.

A primeiro delas, recebe dois vértices $u$ e $v$ que estão em árvores distintas, e cria uma aresta de peso $w$, conectando-os. Primeiramente, devemos lembrar que as arestas da árvore representada viram vértices em nossa representação interna. Com isso, o primeiro passo é criar um vértice que tem seu valor definido como $w$, vamos chama-lo \texttt{uv\_edge}. Dessa forma, criaremos as seguintes conexões: $u \leftrightarrow uv\_edge \leftrightarrow v$.

Inicialmente, colocamos $v$ como raiz de nossa árvore representada, e criamos um caminho preferido que só possui este vértice como integrante. Com isso, conseguimos concatenar este caminho preferido de tamanho unitário com o caminho que \texttt{uv\_edge} constitui. A seguir, aplicamos a mesma ideia, criando um caminho unitário que contém $u$ e o concatenando com um caminho que possui $v$ e \texttt{uv\_edge}.

\begin{programruledcaption}{Link\label{lct:link}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]   
        funcao link(u, v, w) // $u$ e $v$ em árvores distintas
            uv_edge := new Node(w) // cria nó com peso $w$
            // ligando (v) - (uv\_edge)
            make_root(v)
            access(v)
            join(v, uv_edge)
            // ligando (uv\_edge)-(u)
            make_root(u);
            access(u);
            access(uv_edge);
            join(uv_edge, u)
        fim
    \end{lstlisting}
\end{programruledcaption}


Já a operação \texttt{cut(u, v)}, que separa dois nós, é um pouco mais simples. Note que, temos que separar as conexões entre $u$ e \texttt{uv\_edge} assim como entre \texttt{uv\_edge} e $v$. O processo de separação é igual para as duas partes, por isso, vamos explicar somente a separação de $u$ e \texttt{uv\_edge}.

A ideia é colocarmos $u$ como raiz de nossa árvore representada, com isso, podemos criar um caminho preferido vai de $u$ até $u$ e \texttt{uv\_edge}. Agora, basta usarmos nossa operação $u$ e \texttt{split(uv\_edge)}, que separa \texttt{uv\_edge} da parte superior de seu caminho preferido, efetivamente quebrando sua conexão com $u$.

\begin{programruledcaption}{Cut\label{lct:cut}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},,
    ]
        funcao cut(u, v) // $u$ e $v$ na mesma árvore
            // cortando (u) - (uv\_edge)
            make_root(u)
            access(uv_edge)
            split(uv_edge)
            // cortando (v) - (uv\_edge)
            make_root(v)
            access(uv_edge)
            split(uv_edge)
        fim
    \end{lstlisting}
\end{programruledcaption}

\subsection{Consultas Is Connected e Maximum Edge}
\label{subsection:lct-is-connected}

A função \texttt{is\_connected(u, v)}, que nos informa se $u$ e $v$ pertencem a mesma árvore, funciona da seguinte maneira. Primeiro acessamos $u$, criando um caminho deste até a raiz da árvore. Em seguida, guardamos o vértice que esta no fim desse caminho, isto é, guardamos a raiz da árvore que contém $u$. A seguir, repetimos o mesmo processo com o vértice $v$. Agora, basta compararmos se ambos os valores que guardamos são iguais.

\begin{programruledcaption}{Is Connected\label{lct:is-connected}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},,
    ]
        funcao is_connected(u, v)
            access(u)
            u_tree_root := get_path_end_node(u)
            access(v)
            v_tree_root := get_path_end_node(v)
            devolva (u_tree_root = v_tree_root)
        fim
    \end{lstlisting}
\end{programruledcaption}

Por último, temos a função \texttt{maximum\_edge(u, v)}, que retorna o peso da maior aresta no caminho simples entre $u$ e $v$. Como transformamos as arestas em vértices na nossa representação interna, precisamos procurar o maior valor de um vértice no caminho preferido entre $u$ e $v$. Para isso, transformamos $v$ na raiz de nossa árvore e acessamos $u$. Com isso, podemos utilizar \texttt{get\_maximum\_path\_value(u)} para obter o maior valor contido neste caminho preferido.

\begin{programruledcaption}{Maximum Edge\label{lct:max-edge}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},,
    ]
        funcao maximum_edge(u, v) // $u$ e $v$ na mesma árvore
            make_root(v);
            access(u);
            devolva get_maximum_path_value(u)
        fim
    \end{lstlisting}
\end{programruledcaption}

E com isso, encerramos a explicação da implementação dos métodos da link-cut tree.

%% ------------------------------------------------------------------------- %%
%% ------------------------------------------------------------------------- %%
%% ------------------------------------------------------------------------- %%
%% ------------------------------------------------------------------------- %%
\section{Splay Tree}
\label{sec:lct-splay-trees}

No artigo original, Sleator e Tarjan propuseram a utilização de uma árvore binária enviesada como estrutura para os caminhos preferidos. Porém, quatro anos depois, eles apresentaram a splay tree ~\citep{10.1145/3828.3835}, que possibilita realizarmos as operações necessárias para a manipulação dos caminhos preferidos em tempo $\Oh(\log n)$ amortizado, com uma implementação muito mais limpa do que a da versão original. Portanto, usaremos a splay trees para armazenar os caminhos preferidos.

Uma splay tree é uma árvore binária de busca auto-balanceável. Estas árvores utilizam rotações para auto-balancear, através de uma operação chamada \texttt{splay}. A operação \texttt{splay}, traz um nó para a raiz da árvore através de sucessivas rotações. Mas antes de nos aprofundarmos neste método, examinaremos como os caminhos preferidos são representados aqui.

Primeiramente, em nosso uso, a ordenação dos nós na splay tree é dada pela profundidade destes na link-cut tree. Note que não guardamos explicitamente esses valores. Em vez disso, utilizamos a ideia de chave implícita, isto é, só nos preocupamos em manter a ordem relativa dos nós após as operações de separação e união das árvores, apresentadas a seguir. Em contrapartida, com este método, perdemos a capacidade de realizarmos buscas por chave na splay tree, porém não necessitamos dessa operação.

Ademais, para implementar eficientemente a operação \texttt{get\_maximum\_path\_value}, mantemos o peso máximo dos nós em cada sub-árvore de uma splay tree.

\begin{center}
    \textbf{TODO}: colocar imagem de um preferred path e sua respectiva splay tree.
    % splay tree com os campos e arestas como vértices
    % enraizar splay no centro do caminho e destacar na legenda que essa é apenas umas das possíveis configurações dessa árvore auxiliar em particular
\end{center}

Além disso, como usamos a profundidade dos nós na árvore representada como chave para a árvore auxiliar, temos que todos os nós na sub-árvore esquerda da raiz de uma splay tree têm uma profundidade menor que a raiz, enquanto os nós à direita têm uma profundidade maior. Contudo, ao realizamos uma operação \texttt{make\_root(u)}, fazemos com que todos os nós que estavam acima de $u$ na árvore representada se tornem parte de sua sub-árvore. Para isso, incluímos na splay tree um mecanismo para inverter a ordem de todos os nós de uma árvore auxiliar, efetivamente invertendo a orientação de um caminho preferido.

\begin{center}
    \textbf{TODO}: colocar imagem de uma splay tree antes e depois da inversão, assim como sua árvore representada.
\end{center}

Com isso, os nós da árvore auxiliar têm os seguintes campos:

\begin{itemize}
    \item \texttt{parent}: apontador para o pai na splay tree. Caso o nó em particular seja a raiz da árvore auxiliar, este campo armazena um ponteiro para o vértice que está logo acima do fim deste caminho preferido na árvore representada.
    \item \texttt{left\_child} e \texttt{right\_child}: apontadores para os filhos esquerdo e direito de um nó na splay tree.
    \item \texttt{value}: se o nó representa uma aresta da árvore representada guarda o peso desta aresta, senão guarda 0.
    \item \texttt{is\_reversed}: valor booleano para sinalizar se a sub-árvore do nó esta com sua ordem invertida ou não, isto é, se todas as posições de filhos esquerdos e direitos estão  invertidas nessa  sub-árvore.
    \item \texttt{max\_subtree\_value}: guarda o valor máximo armazenado na sub-árvore do nó.
\end{itemize}

\subsection{Splay}
\label{subsection:lct-splay-splay}

Com a estrutura apresentada, podemos partir para a explicação de sua principal operação, a \texttt{splay}. Em poucas palavras, este método é responsável por receber um nó e fazer com que ele vire a raiz da splay tree, através de diversas rotações.  Ademais, as operações de \texttt{splay} contribuem para diminuir a altura da árvore, melhorando o seu consumo de tempo.

\begin{center}
    \textbf{TODO}: Colocar figura de uma Splay antes e depois do Splay em uma folha
\end{center}

Em particular, podemos dizer que esta operação é responsável por transformar um vértice em identificador de seu caminho, ou seja, entendemos como sinônimos os métodos \texttt{make\_identifier} e \texttt{splay}.

De modo a facilitarmos nossa explicação, chamamos \texttt{parent} o pai de um nó $u$ e de \texttt{grandparent} o pai de \texttt{parent}.

Primeiramente, uma operação de \texttt{splay} consiste em realizamos diversos passos de \emph{splay}, que trazem $u$ cada vez mais próximo à raiz da árvore, isto é, em cada um desses passos, realizamos uma rotação que diminui a profundidade de $u$. Porém, ao realizar estes passos, temos que nos preocupar com dois fatores:

\begin{itemize}
    \item A propagação do valor booleano $is\_reversed$ de \texttt{grandparent} e em seguida o de \texttt{parent}, fazendo as devidas reversões caso necessárias. Isso nos fornece a invariante de que iremos fazer comparações entre os filhos corretos para determinar qual rotação fazer.
    \item A orientação que \texttt{grandparent}, \texttt{parent} e $u$ se encontram, isto é, se estão em uma orientação de \textit{zig-zig}, \textit{zag-zag} ou \textit{zig-zag}, como exemplificadas na figura abaixo. Dependendo da orientação, fazemos uma rotação em $u$ ou em \texttt{parent}, sempre com a ideia de diminuirmos em 1 a profundidade de $u$.
\end{itemize}

\begin{center}
    \textbf{TODO}: Colocar figura mostrando configurações de zig-zig, zag-zag e zig-zags.
\end{center}

Ao sair da função \texttt{splay}, o nó $u$ estará na raiz de sua árvore auxiliar. Além disso, seu valor booleano $is\_reversed$ estará nulo, pois as reversões já terão sido propagadas aos seus filhos, e seu $max\_subtree\_value$ estará atualizado, contendo o maior valor presente na splay tree.

\begin{programruledcaption}{\label{splay:splay}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]
        funcao splay(u)
            enquanto !u.is_root() // $u$ não ser raiz da LCT e nem da Splay
                parent := u.parent
                grandparent := parent.parent
                se !parent.is_root()
                    // propagamos o \texttt{is\_reversed} bit do \texttt{grandparent} para o \texttt{parent} para garantir que a condicional a seguir usa os filhos corretos para a comparação
                    grandparent.push_reversed_bit()
                    parent.push_reversed_bit()
                    se (grandparent.r_child = parent) = (parent.r_child = u))
                        // zig-zig ou zag-zag
                        rotate(parent)
                    senao
                        // zig-zag
                        rotate(u)
                rotate(u)
            u.push_reversed_bit()
        fim
    \end{lstlisting}
\end{programruledcaption}

Assim como a operação acima, o restante da nossa implementação de uma splay tree é bastante tradicional. Com isso, nossos únicos cuidados extras são a manutenção do bit \texttt{is\_reversed}, do valor máximo das sub-arvores e da manutenção das chaves implícitas. Assim, no método \texttt{rotate(u)}, temos como primeiro passo a propagação do bit \texttt{is\_reversed} de \texttt{grandparent} até $u$ e como última etapa o cálculo dos novos valores de \texttt{max\_subtree\_value}.

\subsection{Split e Join}
\label{subsection:lct-splay-split-join}

Temos também dois métodos importantes das splay trees usados na manutenção dos caminhos preferidos, \texttt{split} e \texttt{join}, responsáveis por separar e concatenar caminhos preferidos, respectivamente.

\begin{programruledcaption}{\label{splay:split}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]
        funcao split(u)
            se u.l_child != NULL
                u.l_child.parent := NULL    
            u.l_child := NULLl
        fim
    \end{lstlisting}
\end{programruledcaption}

Primeiramente, falaremos do método \texttt{split(u)}, que recebe um nó $u$ e separa caminho preferido que o contem em dois. Para isso, ele simplesmente separa a sub-árvore esquerda de $u$, como mostrado acima. Vale notar que, este método é destrutivo: removendo tanto o ponteiro para o filho preferido de $u$ quanto o ponteiro \texttt{parent} que tal filho possui para $u$. Logo, usamos essa rotina apenas para o \texttt{cut()} da link-cut tree.

\begin{programruledcaption}{\label{splay:join}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]
        funcao join(u, v)
            se v != NULL
                v.parent := u
            u.r_child := v
            // atualiza \texttt{max\_subtree\_value} com o máximo entre o \texttt{value} dos dois filhos e de $u$ 
            u.recalculate_max_subtree_value() 
        fim
    \end{lstlisting}
\end{programruledcaption}

De maneira complementar, temos a rotina \texttt{join(u, v)} que recebe dois nós e concatena os respectivos caminhos preferidos. Para isso, assume-se que ambos os nós sejam identificadores de seus caminhos preferidos, ou seja, que eles sejam as raízes de suas splay trees. Com isso, simplesmente colocamos a splay tree em que $v$ é raiz como a sub-árvore direita de $u$, atualizando os respetivos apontadores e recalculando o valor máximo na splay tree de $u$. Note que, a sub-árvore direita inicial, que constitui a parte do caminho preferido de $u$ que foi substituída, ficará com um apontador \texttt{parent} para $u$.

\subsection{Métodos auxiliares}
\label{subsection:lct-splay-aux}

Para finalizar, nossa splay tree possui quatro métodos auxiliares, o \texttt{reverse\_path}, \texttt{get\_path\_end\_node}, \texttt{get\_parent\_path\_node} e \texttt{get\_maximum\_path\_value}.

\begin{programruledcaption}{\label{splay:reverse-path}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]
        funcao reverse_path(u)
            u.is_reversed := !u.is_reversed // inverte o valor do bit
            u.push_reversed_bit() // inverte os filhos de $u$ e propaga a inversão do bit
        fim
    \end{lstlisting}
\end{programruledcaption}

Primeiramente, o \texttt{reverse\_path(u)} recebe o identificador de um caminho e inverte a orientação desse caminho. Tal tarefa é realizada invertendo o valor do bit \texttt{is\_reversed} de $u$, com isso, nas próximas operações realizadas neste nó, seus filhos serão trocados de posição e o bit sera propagado na sub-árvore.

\begin{programruledcaption}{Join\label{splay:get-path-end}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]
        funcao get_path_end_node(u)
            splay(u)
            smallest_value := u
            enquanto smallest_value.l_child != NULL
                smallest_value := smallest_value.l_child
            splay(smallest_value) // garantido que sera mais rápido na próxima vez
            devolva smallest_value
        fim
    \end{lstlisting}
\end{programruledcaption}

\begin{programruledcaption}{\label{splay:get-parent-path}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]
        funcao get_parent_path_node(u)
            splay(u)
            devolva u.parent
        fim
    \end{lstlisting}
\end{programruledcaption}

A seguir, os métodos \texttt{get\_path\_end\_node(u)} e \texttt{get\_parent\_path\_node(u)} são usados para acessar o fim e o pai do caminho preferido que contem $u$. Em particular, a primeira rotina retorna o vértice menos profundo do caminho preferido de $u$, fazendo isso ao acessar o vértice mais à esquerda na splay tree. Já o segundo método é responsável por retornar o vértice imediatamente acima do fim do caminho preferido que contêm $u$, caso tal caminho contenha a raiz da árvore representada, este método retorna \texttt{null}. Para fazer isso, efetuamos uma operação \texttt{splay} em $u$ e retornamos o valor de \texttt{parent}.

\begin{programruledcaption}{\label{splay:get-maximum-value}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]
        funcao get_maximum_path_value(u)
            devolva u.max_subtree_value
        fim
    \end{lstlisting}
\end{programruledcaption}

Por último, temos a função \texttt{get\_maximum\_path\_value(u)}, que recebe um vértice identificador de caminho $u$ e retorna o maior valor de uma aresta no caminho preferencial de $u$, em termos práticos, retorna o valor de \texttt{max\_subtree\_value}.

\begin{center}
    \textbf{TODO}: Incluir figura de uma Splay antes e depois da reversão do caminho, colocando na legenda o que cada operação retornaria.
\end{center}

Com isso, temos todas as ferramentas necessárias para manipularmos a splay tree em seu uso como árvore auxiliar.