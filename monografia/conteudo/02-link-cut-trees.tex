%!TeX root=../tese.tex
%("dica" para o editor de texto: este arquivo é parte de um documento maior)
% para saber mais: https://tex.stackexchange.com/q/78101/183146

%% ------------------------------------------------------------------------- %%
\chapter{Link-Cut Trees}
\label{cap:link-cut-trees}

Neste capítulo, apresentaremos a estrutura de dados Link-Cut Tree, introduzida por ~\citet{10.1145/800076.802464}. Esta árvore serve como base para as estruturas retroativas apresentadas nos próximos capítulos.

%% ------------------------------------------------------------------------- %%
\section{Ideia}
\label{sec:lct-ideia}

A Link-Cut Tree é uma estrutura de dados que nos permite manter uma floresta de árvores enraizadas, onde os nós de cada árvore possuem um número arbitrário de filhos. Ademais, essa estrutura nos fornece o seguinte conjunto de operações:

\begin{itemize}
    \item \texttt{make\_root(u)}: enraíza no vértice $u$ a árvore que o contém.
    \item \texttt{link(u, v, w)}: dado que os vértices $u$ e $v$ estão em árvores separadas, transforma $v$ em raiz de sua árvore e o liga como filho de $u$, colocando peso $w$ na nova aresta criada.
    \item \texttt{cut(u, v)}: retira da árvore a aresta com pontas em $u$ e $v$, efetivamente separando estes vértices e criando duas novas árvores.
\end{itemize}

Por último, a Link-Cut Tree possui a capacidade de realizar operações agregadas nos vértices, isto é, consultas acerca de propriedades de uma sub-árvore ou de um caminho entre dois vértices. Em particular, estamos interessados na rotina \texttt{maximum\_edge(u, v)}, que nos informa o peso máximo de uma aresta no caminho entre os vértices $u$ e $v$.

Todas essas operações consomem tempo $O(\log n)$ amortizado, onde $n$ é o número de vértices na floresta.

%% ------------------------------------------------------------------------- %%
\section{Definições}
\label{sec:lct-definicoes}

Primeiramente, precisamos fazer algumas definições acerca da estrutura que vamos estudar.

Chamamos de árvores representadas as árvores genéricas que nossa estrutura sintetiza. Para a representação que a Link-Cut Tree utiliza, internamente dividimos uma árvore representada em caminhos vértice-disjuntos, os chamados caminhos preferidos. Todo caminho preferido vai de um vértice a um ancestral deste vértice na arvore representada. Por conveniência, definimos o início de um caminho preferido como o vértice mais profundo contido nele.

Se uma aresta faz parte de um caminho preferido, a chamamos de aresta preferida. Ademais, mantemos a propriedade de que um vértice pode ter no máximo uma aresta preferida com a outra ponta em algum de seus filhos. Caso tal aresta exista, ela liga um vértice a seu filho preferido.

Finalmente, para cada caminho preferido, elegemos um vértice como seu identificador. A manutenção deste vértice será importante para a estrutura auxiliar que utilizaremos para manter os caminhos preferidos, dado que tais vértices serão responsáveis por guardar um ponteiro para o vértice do caminho preferido imediatamente acima do caminho que o contem.

\begin{center}
    \textbf{TODO}: colocar imagem de uma árvore representada e seus caminhos preferidos.
\end{center}

%% ------------------------------------------------------------------------- %%
% access e como implementa o resto
\section{Operações}
\label{sec:lct-operacoes}

Nessa seção, apresentaremos o código por trás das operações que estamos interessados em implementar na Link-Cut Tree. Em um primeiro momento, assumiremos que já sabemos como implementar alguns métodos que lidam com os caminhos preferidos. Desta forma, a implementação dos métodos abaixo fica reservada para a próxima seção.

\begin{itemize}
    \item \texttt{make\_identifier(u)}: transforma um vértice $u$ em identificador de seu caminho preferido.
    \item \texttt{split(u)}: recebe um nó $u$ e separa o caminho preferido que contem este nó em dois, quebrando a conexão entre $u$ e seu filho preferido, caso exista.
    \item \texttt{join(u, v)}: recebe dois nós, $u$ e $v$ --- identificadores de seus caminhos e com $v$ mais profundo que $u$ na árvore representada --- e concatena os respectivos caminhos preferidos, transformando $\{u,v\}$ em aresta preferida. Com isso, separa $u$ da parte mais profunda de seu caminho preferido inicial, deixando o identificador de tal caminho com um ponteiro para $u$. Ao final da operação, $u$ sera o identificador do novo caminho criado.
    \item \texttt{reverse\_path(u)}: recebe $u$, o identificador de um caminho preferido, e inverte a orientação desse caminho, isto é, o fim se transforma no começo e o começo no fim.
    \item \texttt{get\_path\_end\_node(u)}: retorna o vértice menos profundo do caminho preferido de $u$, em outras palavras, o vértice no fim do caminho preferido que contém $u$.
    \item \texttt{get\_parent\_path\_node(u)}: retorna o vértice imediatamente acima do fim do caminho preferido que contêm $u$, caso tal caminho contenha a raiz da árvore representada, este método retorna \texttt{null}.
    \item \texttt{get\_maximum\_path\_value(u)}:  recebe $u$, o identificador de um caminho preferido, e retorna o maior valor de uma aresta neste caminho.
\end{itemize}

Com tal conjunto de funções, podemos avançar para os métodos da Link-Cut Tree.

\subsection{Access}
\label{subsection:lct-access}

\begin{programruledcaption}{\label{lct:access}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},,
    ]
        funcao access(u)
            last := NULL
            current_root := u
            // concatena todos os caminhos preferidos de $u$ até a raiz da árvore representada
            enquanto current_root != NULL
                splayTree.splay(current_root)      // faz $u$ virar o representante de seu caminho preferido 
                splayTree.join(current_root, last) // concatena um novo pedaço de caminho preferido ao caminho em que \texttt{last} é identificador
                last := current_root // \texttt{current\_root} agora é identificador
                current_root := splayTree.get_parent_path_node(current_root)
            splayTree.splay(u)
        fim
    \end{lstlisting}
\end{programruledcaption}


\subsection{Make Root}
\label{subsection:lct-make-root}

\begin{programruledcaption}{\label{lct:make-root}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},,
    ]
        funcao make_root(u)
            access(u)
            splayTree.reverse_path(u)
        fim
    \end{lstlisting}
\end{programruledcaption}

\subsection{Link e Cut}
\label{subsection:lct-link-cut}

\begin{programruledcaption}{\label{lct:link}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},,
    ]
        funcao link(u, v, w)
            uv_edge := new Node(w) // cria nó com peso $w$
            // ligando (uv\_edge)-(v)
            make_root(v)
            access(v)
            splayTree.join(v_node, uv_edge)
            // ligando (uv\_edge)-(u)
            make_root(u);
            access(u);
            access(uv_edge);
            splayTree.join(uv_edge, u_node)
        fim
    \end{lstlisting}
\end{programruledcaption}


\begin{programruledcaption}{\label{lct:cut}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},,
    ]
        funcao cut(u, v)
            // ao cortar dois nos, enraizaremos nossa árvore em $u$ e depois em $v$. Ao fazer isso, podemos fazem uma operação de \texttt{access} no nó que representa a aresta $\{u,v\}$, criando um caminho de tamanho 2 e tem tal aresta como identificador. Assim podemos realizar o corte.
            // cortando (u)-(uv\_edge)
            make_root(u_node)
            access(uv_edge)
            splayTree.split(uv_edge)
            // cortando (v)-(uv\_edge)
            make_root(v_node)
            access(uv_edge)
            splayTree.split(uv_edge)
        fim
    \end{lstlisting}
\end{programruledcaption}


\subsection{Is Connected}
\label{subsection:lct-is-connected}

\begin{programruledcaption}{\label{lct:is-connected}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},,
    ]
        funcao is_connected(u, v)
            access(u)
            u_path_end := splayTree.get_path_end_node(u)
            access(v)
            v_path_end := splayTree.get_path_end_node(v)
            devolva (u_path_end == v_path_end)
        fim
    \end{lstlisting}
\end{programruledcaption}


\subsection{Maximum Edge}
\label{subsection:lct-max-edge}

\begin{programruledcaption}{\label{lct:max-edge}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},,
    ]
        funcao maximum_edge(u, v)
            make_root(v);
            access(u); // cria um caminho preferido entre $u$ e $v$
            devolva splayTree.get_maximum_path_value(u)
        fim
    \end{lstlisting}
\end{programruledcaption}

%% ------------------------------------------------------------------------- %%
%% ------------------------------------------------------------------------- %%
%% ------------------------------------------------------------------------- %%
%% ------------------------------------------------------------------------- %%
\section{Splay Trees}
\label{sec:lct-splay-trees}

No artigo original, os autores utilizam uma árvore binária enviesada como estrutura para os caminhos preferidos. Porém, quatro anos depois, ~\citet{10.1145/3828.3835} apresentaram a Splay Tree, que possibilita realizarmos as operações necessárias para a manipulação dos caminhos preferidos em tempo $O(\log n)$ amortizado, com uma implementação muito mais limpa do que a da versão original. Portanto, usaremos a Splay Tree como uma arvore auxiliar que cuida de manter os caminhos preferidos.

A Splay Tree é uma árvore binária de busca auto-ajustável, capaz de realizar as operações de inserção, deleção e busca. Em particular, para seu uso como árvore auxiliar, estamos interessados na sua operação \texttt{splay}, que traz um nó para a raiz da árvore através de sucessivas rotações. Mas antes de nos aprofundarmos neste método, examinaremos como os caminhos preferidos são representados aqui.

Primeiramente, em nosso uso, a ordenação dos nós na Splay Tree é dada pela profundidade destes na Link-Cut Tree. Note que, não guardamos explicitamente esses valores. Em vez disso, utilizamos a ideia de chave implícita, isto é, só nos preocupamos em manter a ordem relativa dos nós após as operações de separação e união das árvores, apresentadas a seguir. Em contrapartida, com este método, perdemos a capacidade de realizarmos buscas por chave na Splay Tree, porém não necessitamos dessa operação.

Ademais, para podermos lidar com os pesos nas arestas da Link-Cut Tree, fazemos com que cada aresta da árvore representada vire um nó na árvore auxiliar. Isso nos permite calcular eficientemente o peso máximo de uma aresta em um caminho preferido, dado que podemos facilmente manter o peso máximo dos vértices em cada sub-árvore de uma Splay Tree.

\begin{center}
    \textbf{TODO}: colocar imagem de um preferred path e sua respectiva splay tree.
    % splay tree com os campos e arestas como vértices
    % enraizar splay no centro do caminho e destacar na legenda que essa é apenas umas das possíveis configurações dessa árvore auxiliar em particular
\end{center}

Além disso, como usamos a profundidade dos nós na árvore representada como chave para a árvore auxiliar, temos que todos os nós na sub-árvore esquerda da raiz de uma Splay Tree têm uma profundidade menor que a raiz, enquanto os nós á direita têm uma profundidade maior. Contudo, ao realizamos uma operação \texttt{make\_root(u)}, fazemos com que todos os nós que estavam acima de $u$ na árvore representada se tornem parte de sua sub-árvore. Para isso, incluímos na Splay Tree um mecanismo para inverter a ordem de todos os nós de uma árvore auxiliar, efetivamente invertendo a orientação de um caminho preferido.

\begin{center}
    \textbf{TODO}: colocar imagem de uma Splay antes e depois da inversão, assim como sua árvore representada.
\end{center}

Com isso, os nós da árvore auxiliar têm os seguintes campos:

\begin{itemize}
    \item \texttt{parent}: apontador para o pai na Splay Tree. Caso o nó em particular seja a raiz da árvore auxiliar, este campo armazena um ponteiro para o vértice que está logo acima do fim deste caminho preferido na árvore representada.
    \item \texttt{left\_child} e \texttt{right\_child}: apontadores para os filhos esquerdo e direito de um nó na Splay Tree.
    \item \texttt{value}: guarda o peso de uma aresta da árvore representada transformado em vértice na árvore auxiliar.
    \item \texttt{is\_reversed}: valor booleano para sinalizar se a sub-árvore do nó esta com sua ordem invertida ou não, isto é, se todas as posições de filhos esquerdos e direitos estão  invertidas nessa  sub-árvore.
    \item \texttt{max\_subtree\_value}: guarda o valor máximo armazenado na sub-árvore do nó.
\end{itemize}

\subsection{Splay}
\label{subsection:lct-splay-splay}

Com a estrutura apresentada, podemos partir para a explicação de sua principal operação, a \texttt{splay}. Em poucas palavras, este método é responsável por receber um nó e fazer com que ele vire a raiz da Splay Tree, através de diversas rotações.  Ademais, as operações de \texttt{splay} contribuem para diminuir a altura da árvore, melhorando o seu consumo de tempo.

\begin{center}
    \textbf{TODO}: Colocar figura de uma Splay antes e depois do Splay em uma folha
\end{center}

Em particular, podemos dizer que esta operação é responsável por transformar um vértice em identificador de seu caminho, ou seja, entendemos como sinônimos os métodos \texttt{make\_identifier} e \texttt{splay}.

De modo a facilitarmos nossa explicação, chamamos \texttt{parent} o pai de um nó $u$ e de \texttt{grandparent} o pai de \texttt{parent}. Primeiramente, recebemos um nó $u$ da Splay Tree, e enquanto este nó não é raiz de nossa árvore, conduzimos a seguinte rotina:

\begin{itemize}
    \item Verifico se \texttt{parent} é a raiz da árvore, caso positivo, vou para o último item.
    \item Caso contrario, propagamos o valor booleano $is\_reversed$ de \texttt{grandparent} e em seguida o de \texttt{parent}, fazendo as devidas reversões caso necessárias. Isso nos fornece a invariante de que iremos fazer a comparação a seguir entre os filhos corretos.
    \item Em seguida, checamos se \texttt{grandparent}, \texttt{parent} e $u$ estão em uma orientação de \textit{zig-zig}, \textit{zag-zag} ou \textit{zig-zag}, como exemplificadas na figura abaixo. Dependendo da orientação, fazemos uma rotação em $u$ ou em \texttt{parent}, sempre com a ideia de diminuirmos em 1 a profundidade de $u$.
    \item Por último, fazemos uma rotação em $u$, o que o coloca na profundidade que inicialmente estava o nó \texttt{grandparent}.
\end{itemize}

\begin{center}
    \textbf{TODO}: Colocar figura mostrando configurações de zig-zig, zag-zag e zig-zags.
\end{center}

Ao sair da função \texttt{splay}, o nó $u$ estará na raiz de sua árvore auxiliar. Além disso, seu valor booleano $is\_reversed$ estará nulo, pois as reversões já terão sido propagadas aos seus filhos, e seu $max\_subtree\_value$ estará atualizado, contendo o maior valor presente na Splay Tree.

\begin{programruledcaption}{\label{splay:splay}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]
        funcao splay(u)
            enquanto !u.is_root() // $u$ não ser raiz da LCT e nem da Splay
                parent := u.parent
                grandparent := parent.parent
                se !parent.is_root()
                    // propagamos o \texttt{is\_reversed} bit do \texttt{grandparent} para o \texttt{parent} para garantir que a condicional a seguir usa os filhos corretos para a comparação
                    grandparent.push_reversed_bit()
                    parent.push_reversed_bit()
                    se (grandparent.r_child == parent) == (parent.r_child == u))
                        // zig-zig ou zag-zag
                        rotate(parent)
                    senao
                        // zig-zag
                        rotate(u)
                rotate(u)
            u.push_reversed_bit()
        fim
    \end{lstlisting}
\end{programruledcaption}

Agora, olharemos a função responsável por realizar as rotações. Basicamente ela pode ser fatorada em quatro partes:

\begin{itemize}
    \item Primeiramente propagamos as reversões de \texttt{grandparent}, \texttt{parent} e $u$, garantindo que estaremos acessando e manipulando os filhos corretos destes respectivos nós.
    \item Em seguida, caso o \texttt{parent} não seja a raiz da Splay Tree, o trocamos  de lugar com $u$, efetivamente colocando $u$ como algum dos filhos de \texttt{grandparent}.
    \item Agora, basta colocarmos \texttt{parent} como algum dos filhos $u$, espelhando a orientação inicial em que $u$ estava como filho de \texttt{parent}.
    \item Por último, recalculamos os valores máximos nas sub-árvores de \texttt{parent} e de $u$.
\end{itemize}

\subsection{Split e Join}
\label{subsection:lct-splay-split-join}

Temos também dois métodos importantes para a manutenção dos caminhos preferidos, \texttt{split} e \texttt{join}, responsáveis por separar e concatenar caminhos preferidos, respectivamente.

\begin{programruledcaption}{\label{splay:split}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]
        funcao split(u)
            se u.l_child != NULL
                u.l_child.parent := NULL    
            u.l_child := NULLl
        fim
    \end{lstlisting}
\end{programruledcaption}

Primeiramente, falaremos do método \texttt{split(u)}, que recebe um nó $u$ e separa caminho preferido que o contem em dois. Para isso, ele simplesmente separa a sub-árvore esquerda de $u$, como mostrado acima. Vale notar que, este método é destrutivo: removendo tanto o ponteiro para o filho preferido de $u$ quanto o ponteiro \texttt{parent} que tal filho possui para $u$. Logo, usamos essa rotina apenas para o \texttt{cut()} da Link-Cut Tree.

\begin{programruledcaption}{\label{splay:join}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]
        funcao join(u, v)
            se v != NULL
                v.parent := u
            u.r_child := v
            // atualiza \texttt{max\_subtree\_value} com o máximo entre o \texttt{value} dos dois filhos e de $u$ 
            u.recalculate_max_subtree_value() 
        fim
    \end{lstlisting}
\end{programruledcaption}

De maneira complementar, temos a rotina \texttt{join(u, v)} que recebe dois nós e concatena os respectivos caminhos preferidos. Para isso, assume-se que ambos os nós sejam identificadores de seus caminhos preferidos, ou seja, que eles sejam as raízes de suas Splay Trees. Com isso, simplesmente colocamos a Splay Tree em que $v$ é raiz como a sub-árvore direita de $u$, atualizando os respetivos apontadores e recalculando o valor máximo na Splay Tree de $u$. Note que, a sub-árvore direita inicial, que constitui a parte do caminho preferido de $u$ que foi substituída, ficará com um apontador \texttt{parent} para $u$.

\subsection{Métodos auxiliares}
\label{subsection:lct-splay-aux}

Para finalizar, nossa Splay Tree possui quatro métodos auxiliares, o \texttt{reverse\_path}, \texttt{get\_path\_end\_node}, \texttt{get\_parent\_path\_node} e \texttt{get\_maximum\_path\_value}.

\begin{programruledcaption}{\label{splay:reverse-path}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]
        funcao reverse_path(u)
            u.is_reversed := !u.is_reversed // inverte o valor do bit
            u.push_reversed_bit() // inverte os filhos de $u$ e propaga a inversão do bit
        fim
    \end{lstlisting}
\end{programruledcaption}

Primeiramente, o \texttt{reverse\_path(u)} recebe o identificador de um caminho e inverte a orientação desse caminho. Tal tarefa é realizada invertendo o valor do bit \texttt{is\_reversed} de $u$, com isso, nas próximas operações realizadas neste nó, seus filhos serão trocados de posição e o bit sera propagado na sub-árvore.

\begin{programruledcaption}{Join\label{splay:get-path-end}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]
        funcao get_path_end_node(u)
            splay(u)
            smallest_value := u
            enquanto smallest_value.l_child != NULL
                smallest_value := smallest_value.l_child
            splay(smallest_value) // garantido que sera mais rápido na próxima vez
            devolva smallest_value
        fim
    \end{lstlisting}
\end{programruledcaption}

\begin{programruledcaption}{\label{splay:get-parent-path}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]
        funcao get_parent_path_node(u)
            splay(u)
            devolva u.parent
        fim
    \end{lstlisting}
\end{programruledcaption}

A seguir, os métodos \texttt{get\_path\_end\_node(u)} e \texttt{get\_parent\_path\_node(u)} são usados para acessar o fim e o pai do caminho preferido que contem $u$. Em particular, a primeira rotina retorna o vértice menos profundo do caminho preferido de $u$, fazendo isso ao acessar o vértice mais à esquerda na Splay Tree. Já o segundo método é responsável por retornar o vértice imediatamente acima do fim do caminho preferido que contêm $u$, caso tal caminho contenha a raiz da árvore representada, este método retorna \texttt{null}. Para fazer isso, efetuamos uma operação \texttt{splay} em $u$ e retornamos o valor de \texttt{parent}.

\begin{programruledcaption}{\label{splay:get-maximum-value}}
    \begin{lstlisting}[
      language={[brazilian]pseudocode},
      style=pseudocode,
      style=wider,
      keepspaces=true,
      commentstyle=\color{gray},
    ]
        funcao get_maximum_path_value(u)
            devolva u.max_subtree_value
        fim
    \end{lstlisting}
\end{programruledcaption}

Por último, temos a função \texttt{get\_maximum\_path\_value(u)}, que recebe um vértice identificador de caminho $u$ e retorna o maior valor de uma aresta no caminho preferencial de $u$, em termos práticos, retorna o valor de \texttt{max\_subtree\_value}.

\begin{center}
    \textbf{TODO}: Incluir figura de uma Splay antes e depois da reversão do caminho, colocando na legenda o que cada operação retornaria.
\end{center}

Com isso, temos todas as ferramentas necessárias para manipularmos a Splay Tree em seu uso como árvore auxiliar.