%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%% INSERINDO COMENTÁRIOS EM ARQUIVOS .bib %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% 1. Como em outros arquivos LaTeX, comentários são iniciados por "%" e,
%    portanto, é preciso usar "\%" para imprimir o caractere "%". Esquecer
%    disso pode gerar erros difíceis de encontrar!
%
% 2. Não é possível inserir comentários dentro de uma entrada, apenas fora.
%
% 3. Não é possível incluir o caractere arroba em um comentário.
%
% 4. Se quiser desabilitar temporariamente um campo ("comentar" o campo),
%    troque seu nome para algum nome inválido, como "author-disable".
%    Se quiser fazer alguma observação permanente dentro de uma entrada,
%    você também pode usar algum nome de campo inválido, como "lembrete",
%    ou usar o campo "annotation", que normalmente é ignorado.
%
% 5. Se quiser desabilitar temporariamente uma entrada inteira ("comentar" a
%    entrada), não basta colocar "%" nas linhas correspondentes por causa do
%    caractere arroba; também é preciso remover a arroba.
%
% 6. Na verdade, as regras não são bem essas, mas segui-las é uma boa ideia:
%    https://tex.stackexchange.com/a/262282


% Esta entrada está comentada, ou seja, não tem efeito: se houvesse uma
% referência a ela no texto, a referência ficaria inválida. Observe que,
% para isso, o caractere arroba foi apagado!
%Book{JW82,
% author    = {Richard A. Johnson and Dean W. Wichern},
% title     = {Applied Multivariate Statistical Analysis},
% publisher = {Prentice-Hall},
% year      = {1983}
%}

@inproceedings{10.1145/800076.802464,
    author    = {Sleator, Daniel D. and Tarjan, Robert Endre},
    title     = {A Data Structure for Dynamic Trees},
    year      = {1981},
    isbn      = {9781450373920},
    publisher = {Association for Computing Machinery},
    address   = {New York, NY, USA},
    url       = {https://doi.org/10.1145/800076.802464},
    doi       = {10.1145/800076.802464},
    abstract  = {We propose a data structure to maintain a collection of vertex-disjoint trees under a sequence of two kinds of operations: a link operation that combines two trees into one by adding an edge, and a cut operation that divides one tree into two by deleting an edge. Our data structure requires O(log n) time per operation when the time is amortized over a sequence of operations. Using our data structure, we obtain new fast algorithms for the following problems:(1) Computing deepest common ancestors.(2) Solving various network flow problems including finding maximum flows, blocking flows, and acyclic flows.(3) Computing certain kinds of constrained minimum spanning trees.(4) Implementing the network simplex algorithm for the transshipment problem.Our most significant application is (2); we obtain an O(mn log n)-time algorithm to find a maximum flow in a network of n vertices and m edges, beating by a factor of log n the fastest algorithm previously known for sparse graphs.},
    booktitle = {Proceedings of the Thirteenth Annual ACM Symposium on Theory of Computing},
    pages     = {114–122},
    numpages  = {9},
    location  = {Milwaukee, Wisconsin, USA},
    series    = {STOC '81}
}

@article{10.1145/3828.3835,
    author     = {Sleator, Daniel D. and Tarjan, Robert Endre},
    title      = {Self-Adjusting Binary Search Trees},
    year       = {1985},
    issue_date = {July 1985},
    publisher  = {Association for Computing Machinery},
    address    = {New York, NY, USA},
    volume     = {32},
    number     = {3},
    issn       = {0004-5411},
    url        = {https://doi.org/10.1145/3828.3835},
    doi        = {10.1145/3828.3835},
    abstract   = {The splay tree, a self-adjusting form of binary search tree, is developed and analyzed. The binary search tree is a data structure for representing tables and lists so that accessing, inserting, and deleting items is easy. On an n-node splay tree, all the standard search tree operations have an amortized time bound of O(log n) per operation, where by “amortized time” is meant the time per operation averaged over a worst-case sequence of operations. Thus splay trees are as efficient as balanced trees when total running time is the measure of interest. In addition, for sufficiently long access sequences, splay trees are as efficient, to within a constant factor, as static optimum search trees. The efficiency of splay trees comes not from an explicit structural constraint, as with balanced trees, but from applying a simple restructuring heuristic, called splaying, whenever the tree is accessed. Extensions of splaying give simplified forms of two other data structures: lexicographic or multidimensional search trees and link/cut trees.},
    journal    = {J. ACM},
    month      = {jul},
    pages      = {652–686},
    numpages   = {35}
}