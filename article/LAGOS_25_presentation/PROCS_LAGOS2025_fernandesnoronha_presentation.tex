%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LaTeX Beamer Presentation (Condensed Version)
%
% On-s minimal.
% Speaker notes are included as comments (%) in each frame.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[fleqn]{beamer}

\usepackage[utf8]{inputenc}
\setlength{\mathindent}{\parindent}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx} 
\usepackage{pifont}
\usepackage{cancel}
\usepackage{tikz}
\usetikzlibrary{calc,positioning,decorations.pathmorphing,decorations.pathreplacing}
\usetikzlibrary{backgrounds}
\usepackage{pgfpages}
\usepackage{./figstyle}
\usepackage{algorithm}
\usepackage{algpseudocode}

\newcommand{\greencheck}{\textbf{\textcolor{green}{\ding{51}}}}
\newcommand{\Oh}{\mathcal{O}}

%------------------------------------------------------------
% Beamer notes
%------------------------------------------------------------
%\setbeameroption{hide notes} % Only slides
% \setbeameroption{show only notes} % Only notes
\setbeameroption{show notes on second screen=right} % Both

% Give a slight yellow tint to the notes page
% \setbeamertemplate{note page}{\pagecolor{yellow!5}\vfill\insertnote\vfill}

%------------------------------------------------------------
% Theme and Color Scheme
%------------------------------------------------------------
\usetheme{Boadilla}

\usecolortheme{default}

\pdfstringdefDisableCommands{%
  \def\\{}%
  \def\texttt#1{<#1>}%
  \def\vspace#1{}%
}

%------------------------------------------------------------
% Presentation Information
%------------------------------------------------------------
\title[Partial to full retroactivity]{How to go from partial to full retroactivity in detail}
\author[Felipe C. Noronha]{Cristina Gomes Fernandes, Felipe Castro de Noronha}
\institute[IME-USP]{
    IME-USP -- Brazil
}
\date{LAGOS 25 -- November 10-14, 2025}

%------------------------------------------------------------
% The Presentation Begins
%------------------------------------------------------------
\begin{document}

%-------------------------------------------------
% Title Page
%-------------------------------------------------
\begin{frame}
    \titlepage
    \note[item]{Introduce yourself: Cristina Gomes Fernandes (IME-USP) and Felipe Castro de Noronha}
    \note[item]{State topic: going from partial to full retroactivity in detail}
    \note[item]{This work addresses a practical limitation in Demaine, Iacono \& Langerman's 2007 transformation}
    \note[item]{Our contribution: same time complexity without requiring persistent data structures}
    \note[item]{Secondary contribution: implementation of semi-retroactive incremental MSF}
    \note[item]{Key insight: we can reuse existing data structures during rebuilding process}
\end{frame}


%-------------------------------------------------
% What is a Spanning Tree?
%-------------------------------------------------
\begin{frame}
    \frametitle{What is a spanning tree?}
    
    \begin{itemize}
    \item Let $G = (V, E)$ be a connected graph \vfill
    \item \textbf{Spanning tree:} A tree with all vertices of $G$ \vfill\pause
    \item \textbf{Properties:}
        \begin{itemize}
        \item Connected (path between any two vertices)
        \item Acyclic (no cycles)
        \item Contains exactly $n-1$ edges for $n$ vertices
        \end{itemize} \vfill\pause
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Graph G edges (blue straight lines - edges NOT in T)
            \draw[blue, thick] (A) -- (B);  % AB
            \draw[blue, thick] (F) -- (G);  % FG
            \draw[blue, thick] (F) -- (D);  % FD
            \draw[blue, thick] (H) -- (D);  % HD  
            \draw[blue, thick] (C) -- (F);  % CF
            \draw[blue, thick] (G) -- (H);  % GH
            
            % Spanning tree T edges (red wavy lines)
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A);  % CA
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F);  % AF
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (D);  % AD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (D);  % GD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (D);  % BD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (E);  % BE
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (H) -- (E);  % HE
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {T};
        \end{tikzpicture}
        \caption{Graph $G$ (blue edges) and spanning tree $T$ (red wavy edges)}
    \end{figure}
    
    \note[item]{Start with basic concept of spanning tree - fundamental in graph theory}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Explain key properties: connected (path between any two vertices), acyclic (no cycles), contains exactly n-1 edges for n vertices}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Show visual example with graph G (blue edges) and spanning tree T (red wavy edges)}
    \note[item]{In the example: 8 vertices, so spanning tree has exactly 7 edges}
    \note[item]{This builds up the concepts step by step for the incremental MSF problem}
    \note[item]{Emphasize that spanning trees are not unique - there can be many valid spanning trees}
    
\end{frame}


%-------------------------------------------------
% Minimum Spanning Tree and Forest
%-------------------------------------------------
\begin{frame}
    \frametitle{Minimum Spanning Tree and Forest}
    
    \begin{itemize}
    \item \textbf{Minimum Spanning Tree (MST):} spanning tree with minimum total cost \vfill\pause
    \item \textbf{Minimum Spanning Forest (MSF):} generalization for disconnected graphs \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Graph G edges (blue straight lines - edges NOT in MST)
            \draw[blue, thick] (A) -- (B) node[midway, above=0.1cm, font=\small] {8};  % AB
            \draw[blue, thick] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};  % FG
            \draw[blue, thick] (F) -- (D) node[midway, left=0.1cm, font=\small] {7};  % FD
            \draw[blue, thick] (H) -- (D) node[midway, right=0.1cm, font=\small] {9};  % HD  
            \draw[blue, thick] (C) -- (F) node[midway, left=0.1cm, font=\small] {5};  % CF
            \draw[blue, thick] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};  % GH
            
            % MST edges (red wavy lines) - with weights that make it minimum
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};  % CA
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};  % AF
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (D) node[midway, above=0.1cm, font=\small] {3};  % AD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (D) node[midway, right=0.1cm, font=\small] {2};  % GD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (D) node[midway, above=0.1cm, font=\small] {3};  % BD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (E) node[midway, right=0.1cm, font=\small] {1};  % BE
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (H) -- (E) node[midway, right=0.1cm, font=\small] {2};  % HE
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MST};
        \end{tikzpicture}
        \caption{Graph $G$ (blue edges) and Minimum Spanning Tree (red wavy edges)}
    \end{figure}

    \note[item]{Define MST as spanning tree with minimum total cost - optimization problem}
    \note[item]{Generalize to MSF for disconnected graphs - collection of MSTs for each component}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Show visual example with weighted edges: blue edges show graph G, red wavy edges show MST}
    \note[item]{Demonstrate that red edges form MST with cost 14 (1+2+3+2+3+1+2 = 14)}
    \note[item]{Explain that any other spanning tree would have higher cost - this is the optimal solution}
    \note[item]{This prepares for the incremental MSF problem where we maintain optimality dynamically}
    \note[item]{Key insight: we need to maintain optimality as edges are added one by one}
\end{frame}

%-------------------------------------------------
% Incremental MSF Problem
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF problem}
    
    \begin{itemize}
    \item \textbf{Problem:} Keep track of an MSF in a graph that grows over time \vfill
    \item Graph starts empty, edges are added one by one \vfill\pause
    \item \textbf{Operations:}
        \begin{itemize}
        \item \texttt{add\_edge}$(u,v,w)$: add edge with cost $w$ between vertices $u$ and $v$
        \item \texttt{get\_msf}(): return a list with the edges of an MSF of $G$
        \end{itemize} \vfill\pause
    \item \textbf{Solution:} Frederickson (1983) using link-cut trees \vfill
    \end{itemize}
    \note[item]{Define incremental MSF problem clearly: maintain MSF as graph grows}
    \note[item]{Emphasize that graph starts empty and grows - this is crucial for our approach}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Show the two key operations: add\_edge(u,v,w) and get\_msf()}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Mention Frederickson's breakthrough solution from 1983 using link-cut trees}
    \note[item]{Note the cost is $O(log n)$ amortized per edge addition using link-cut trees}
    \note[item]{This is the foundation for retroactive version - we'll extend this to handle time}
    \note[item]{Key insight: we need to maintain MSF not just for current state, but for any time t}

\end{frame}

%-------------------------------------------------
% Frederickson's Link-Cut Tree Solution
%-------------------------------------------------
\begin{frame}
    \frametitle{Frederickson's link-cut tree solution}
    
    \begin{itemize}
    \item \textbf{Key insight:} Use link-cut trees to maintain MSF dynamically \vfill\pause
    \item \textbf{Algorithm for adding edge $(u,v,w)$:}
        \begin{enumerate}
        \item Check if $u$ and $v$ are in same component
        \item If not: add edge to forest
        \item If yes: find max cost edge on $u$-$v$ path
        \item If $w < \text{max cost}$: replace max edge with new edge
        \end{enumerate} \vfill\pause
    \item \textbf{Link-cut tree operations:}
        \begin{itemize}
        \item \texttt{find\_max}$(u,v)$: $\Oh(\log n)$ amortized
        \item \texttt{link}$(u,v)$: $\Oh(\log n)$ amortized
        \item \texttt{cut}$(u,v)$: $\Oh(\log n)$ amortized
        \end{itemize} \vfill\pause
    \item \textbf{Total cost:} Amortized $\Oh(\log n)$ per edge addition \vfill
    \end{itemize}
    \note[item]{Explain Frederickson's key insight: use link-cut trees to maintain MSF dynamically}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{1. Check connectivity using link-cut trees \(find_root operations\)}
    \note[item]{2. If not connected: add edge directly \(link operation\)}
    \note[item]{3. If connected: find max cost edge on u-v path \(find_max operation\)}
    \note[item]{4. If new edge cheaper: replace max edge \(cut + link operations\)}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{List the specific link-cut tree operations: find\_max, link, cut - all $O(log n)$ amortized}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Emphasize the logarithmic time complexity: $O(log n)$ per edge addition}
    \note[item]{Key insight: link-cut trees support efficient rollback, which we'll need for retroactivity}
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 1
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 1}
    
    \begin{itemize}
    \item \textbf{add\_edge(g, h, 4):} Add edge with cost 4 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edge 1: G-H
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 1: Added edge (g,h) with cost 4}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h\} \vfill
    \end{itemize}
    \note[item]{Show first edge being added: (g,h) with cost 4}
    \note[item]{Explain it's automatically added to MSF since no cycle exists yet}
    \note[item]{Current MSF: {g-h} with total cost 4}
    \note[item]{This demonstrates the incremental nature: we start with empty graph}
    \note[item]{Each step shows how MSF evolves as edges are added}
    \note[item]{Link-cut tree operations: link(g,h) - O(log n) time}
    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 2
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 2}
    
    \begin{itemize}
    \item \textbf{add\_edge(c, a, 1):} Add edge with cost 1 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edges 1-2
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 2: Added edge (c,a) with cost 1}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a\} \vfill
    \end{itemize}
    
    \note[item]{Show second edge being added: (c,a) with cost 1}
    \note[item]{Still no cycle, so added to MSF directly}
    \note[item]{Current MSF: {g-h, c-a} with total cost 5}
    \note[item]{Link-cut tree operations: link(c,a) - O(log n) time}
    \note[item]{We now have two separate components: {g,h} and {c,a}}
    \note[item]{This shows how MSF grows incrementally without cycles}
    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 3
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 3}
    
    \begin{itemize}
    \item \textbf{add\_edge(f, g, 6):} Add edge with cost 6 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edges 1-3
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 3: Added edge (f,g) with cost 6}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g\} \vfill
    \end{itemize}

    \note[item]{Show third edge being added: (f,g) with cost 6}
    \note[item]{Still no cycle, so added to MSF directly}
    \note[item]{Current MSF: {g-h, c-a, f-g} with total cost 11}
    \note[item]{Link-cut tree operations: link(f,g) - O(log n) time}
    \note[item]{Now we have components: {g,h,f} and {c,a}}
    \note[item]{This continues the incremental growth pattern}
    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 4
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 4}
    
    \begin{itemize}
    \item \textbf{add\_edge(a, f, 2):} Add edge with cost 2 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edges 1-4
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 4: Added edge (a,f) with cost 2}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g, a-f\} \vfill
    \end{itemize}
    
    \note[item]{Show fourth edge being added: (a,f) with cost 2}
    \note[item]{Still no cycle, so added to MSF directly}
    \note[item]{Current MSF: {g-h, c-a, f-g, a-f} with total cost 13}
    \note[item]{Link-cut tree operations: link(a,f) - $O(log n)$ time}
    \note[item]{Now we have component: {g,h,f,a,c} - all vertices connected!}
    \note[item]{This shows how components merge as edges are added}
    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 5
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 5}
    
    \begin{itemize}
    \item \textbf{add\_edge(c, f, 5):} Add edge with cost 5 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edge NOT in MSF
            \draw[blue, thick] (C) -- (F) node[midway, above=0.1cm, font=\small] {5};  % CF

            % Edges 1-5
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 5: Added edge (c,f) with cost 5}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g, a-f\} \vfill
    \end{itemize}
    
    \note[item]{Show fifth edge being added: \(c,f\) with cost 5}
    \note[item]{This creates a cycle! c-a-f-g-h-c forms a cycle}
    \note[item]{Link-cut tree operations: find\_max(c,f) finds edge \(a,f\) with cost 2}
    \note[item]{Since new edge cost 5, which is grater than 2, it's not added to the MSF}
    \note[item]{Current MSF: {g-h, c-a, f-g, a-f} with total cost 13}
    \note[item]{This demonstrates the cycle-breaking optimization in Frederickson's algorithm}
    \note[item]{Key insight: we maintain optimality by replacing expensive edges with cheaper ones}
    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 6
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 6}
    
    \begin{itemize}
    \item \textbf{add\_edge(f, d, 7):} Add edge with cost 7 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edge NOT in MSF
            \draw[blue, thick] (C) -- (F) node[midway, above=0.1cm, font=\small] {5};  % CF

            % Edges 1-6
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (D) node[midway, left=0.1cm, font=\small] {7};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 6: Added edge (f,d) with cost 7}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g, a-f, f-d\} \vfill
    \end{itemize}
    
    \note[item]{Show sixth edge being added: \(f,d\) with cost 7}
    \note[item]{This creates a cycle! f-d-g-h-f forms a cycle}
    \note[item]{Link-cut tree operations: find\_max(f,d) no cycle returned}
    \note[item]{Edge is added to the MSF}
    \note[item]{Current MSF: {g-h, c-a, f-g, a-f, f-d} with total cost 20}
    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 7
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 7}
    
    \begin{itemize}
    \item \textbf{add\_edge(a, d, 3):} Add edge with cost 3 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};

            % Edge NOT in MSF
            \draw[blue, thick] (C) -- (F) node[midway, above=0.1cm, font=\small] {5};  % CF
            \draw[blue, thick] (F) -- (D) node[midway, above=0.1cm, font=\small] {7};  % FD
            
            % Edges 1-7
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (D) node[midway, left=0.1cm, font=\small] {3};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 7: Added edge (a,d) with cost 3}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g, a-f, a-d\} \vfill
    \end{itemize}

    \note[item]{Show seventh edge being added: \(a,d\) with cost 3}
    \note[item]{This creates a cycle! a-d-f-a forms a cycle}
    \note[item]{Link-cut tree operations: find\_max(a,d\ finds edge \(f,d\) with cost 7}
    \note[item]{Since new edge cost 3 < max cost 7, we replace (f,d) with (a,d)}
    \note[item]{Current MSF: {g-h, c-a, f-g, a-f, a-d} with total cost 16 \(improved!\)}
    \note[item]{This shows continued optimization as better edges are found}
    \note[item]{Key insight: the algorithm continuously improves the MSF as new edges arrive}
    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 8
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 8}
    
    \begin{itemize}
    \item \textbf{add\_edge(d, g, 2):} Add edge with cost 2 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};

            % Edge NOT in MSF
            \draw[blue, thick] (C) -- (F) node[midway, above=0.1cm, font=\small] {5};  % CF
            \draw[blue, thick] (F) -- (D) node[midway, above=0.1cm, font=\small] {7};  % FD
            \draw[blue, thick] (F) -- (G) node[midway, above=0.1cm, font=\small] {6};  % FG
            
            % Edges 1-7
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (D) -- (G) node[midway, right=0.1cm, font=\small] {2};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (D) node[midway, left=0.1cm, font=\small] {3};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 8: Added edge (d,g) with cost 2}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, a-f, a-d, d-g\} \vfill
    \end{itemize}
    
    \note[item]{Show eighth edge being added: \(d,g\) with cost 2}
    \note[item]{This creates a cycle! d-g-f-a-d forms a cycle}
    \note[item]{Link-cut tree operations: find\_max(d,g) finds edge (f,g) with cost 6}
    \note[item]{Since new edge cost 2 < max cost 6, we replace (f,g) with (d,g)}
    \note[item]{Current MSF: \{g-h, c-a, a-f, a-d, d-g\} with total cost 12 \(improved!\)}
    \note[item]{This shows the final optimization step}
    \note[item]{Key insight: the algorithm finds the optimal MSF through incremental improvements}
    \note[item]{Total cost reduced from 14 to 8 through smart edge replacements}
    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Final Result
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Final Result}
    
    \begin{itemize}
    \item \textbf{Continue adding edges...} \vfill\pause
    \item \textbf{Final MSF:} Minimum spanning forest with optimal cost \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Graph G edges (blue straight lines - edges NOT in MST)
            \draw[blue, thick] (A) -- (B) node[midway, above=0.1cm, font=\small] {8};  % AB
            \draw[blue, thick] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};  % FG
            \draw[blue, thick] (A) -- (D) node[midway, above=0.1cm, font=\small] {3};  % AD
            \draw[blue, thick] (H) -- (D) node[midway, right=0.1cm, font=\small] {9};  % HD  
            \draw[blue, thick] (C) -- (F) node[midway, left=0.1cm, font=\small] {5};  % CF
            \draw[blue, thick] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};  % GH
            
            % MST edges (red wavy lines) - with weights that make it minimum
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};  % CA
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};  % AF
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (D) node[midway, left=0.1cm, font=\small] {1};  % FD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (D) node[midway, right=0.1cm, font=\small] {2};  % GD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (D) node[midway, above=0.1cm, font=\small] {3};  % BD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (E) node[midway, right=0.1cm, font=\small] {1};  % BE
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (H) -- (E) node[midway, right=0.1cm, font=\small] {2};  % HE
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Final MSF with optimal cost = 12}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{Solution:} Frederickson (1983) using link-cut trees \vfill
    \end{itemize}
    
    \note[item]{If we continue adding edges and applying this algorithm}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Show final complete MSF with optimal cost = 12}
    \note[item]{Summarize the incremental process: started empty, added edges one by one}
    \note[item]{Transition to Frederickson's solution: $O(log n)$ amortized per edge addition}
    \note[item]{Key insight: link-cut trees enable efficient cycle detection and edge replacement}
    \note[item]{This sets up the retroactive version: what if we want to query MSF at any time t?}
    \note[item]{The challenge: maintain MSF not just for current state, but for any historical time}
    \note[item]{This motivates the need for retroactive data structures}
    
\end{frame}

%-------------------------------------------------
% What is Retroactivity?
%-------------------------------------------------
\begin{frame}
    \frametitle{What is retroactivity?}
    
    \begin{itemize}
    \item \textbf{Problem:} Data structures usually support updates and queries \vfill
    \item Order of updates affects the state of the data structure \vfill\pause
    \item \textbf{Retroactivity:} Manipulate the sequence of updates \vfill\pause
    \item \textbf{Operations:}
        \begin{itemize}
        \item Insert update at time $t$ (possibly in the past)
        \item Remove update at time $t$
        \item Query at time $t$ (not just present)
        \end{itemize} \vfill
    \end{itemize}
    
    \note[item]{Start with the fundamental problem: data structures depend on update order}
    \note[item]{Explain the motivation: correcting mistakes, adding forgotten operations}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Make it clear that query at any time is crucial for full retroactivity}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Show the three key operations: insert, remove, query at any time}
    \note[item]{Emphasize that time stamps must be distinct - this is important for correctness}
    \note[item]{This sets up the distinction between partial and full retroactivity}
    \note[item]{Key insight: we need to maintain state at every possible time, not just current}
    
\end{frame}

%-------------------------------------------------
% Partial vs Full Retroactivity
%-------------------------------------------------
\begin{frame}
    \frametitle{Partial vs Full retroactivity}
    
    \begin{block}{Partially Retroactive}
        \begin{itemize}
        \item Queries only on \textbf{current} state
        \item Insert/remove updates at any time
        \item Example: Dynamic MSF $\rightarrow$ Partially retroactive MSF
        \end{itemize}
    \end{block} \pause
    
    \begin{block}{Fully Retroactive}
        \begin{itemize}
        \item Queries at \textbf{any} time $t$
        \item Insert/remove updates at any time
        \item Complete retroactive functionality
        \end{itemize}
    \end{block} \pause
    
    \begin{block}{Semi-Retroactive}
        \begin{itemize}
        \item Queries at \textbf{any} time $t$
        \item Insert updates at any time
        \item \textbf{No removal} of updates
        \end{itemize}
    \end{block}
    
    \note[item]{Clearly distinguish between partial, full, and semi-retroactivity}
    \note[item]{Emphasize that partial only allows queries on current state - this is the limitation}
    \note[item]{Give concrete example: dynamic MSF becomes partially retroactive MSF}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Show that full allows queries at any time - much more powerful and useful}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Define semi-retroactive: queries at any time, insertions, but no removals}
    \note[item]{This sets up the challenge: how do we go from partial to full?}
    \note[item]{Key insight: the main difficulty is supporting queries at any time, not just current}
    \note[item]{Our work addresses this challenge with a practical solution}
    
\end{frame}

%-------------------------------------------------
% The Challenge
%-------------------------------------------------
\begin{frame}
    \frametitle{The challenge}
    
    \begin{alertblock}{Challenge}
        How to transform partial $\rightarrow$ full retroactivity?
    \end{alertblock} \pause
    
    \begin{itemize}
    \item \textbf{Problem:} Need to support queries at any time $t$ \vfill
    \item \textbf{Solution approach:} Square-root decomposition \vfill\pause
    \item \textbf{Key insight:} Keep checkpoints with data structure states \vfill
    \item \textbf{Implementation:} Demaine, Iacono \& Langerman (2007) \vfill
    \end{itemize}
    
    \note[item]{State the main challenge clearly: partial to full retroactivity}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Explain what we need to achieve: queries at any time t}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Introduce the solution approach: square-root decomposition}
    \note[item]{Mention the key insight about checkpoints}
    \note[item]{Reference the Demaine et al. work from 2007}
    \note[item]{This motivates the detailed solution in the next slide}
    \note[item]{Key insight: we need to maintain multiple versions of the data structure}
    \note[item]{The challenge: how to do this efficiently without persistent data structures?}
    
\end{frame}

%-------------------------------------------------
% Demaine, Iacono & Langerman's Solution
%-------------------------------------------------
\begin{frame}
    \frametitle{Demaine, Iacono \& Langerman's solution}
    
    \begin{theorem}[Theorem 05]
        Any partially retroactive data structure can be transformed into a fully retroactive one with:
        \begin{itemize}
        \item $\Oh(\sqrt{m})$ slowdown per operation
        \item $\Oh(m)$ space usage
        \item \textbf{Requirement:} Need persistent version of the data structure
        \end{itemize}
    \end{theorem} \pause
    
    \begin{itemize}
    \item \textbf{Key idea:} Square-root decomposition \vfill
    \item Keep $\sqrt{m}$ checkpoints with data structure states \vfill\pause
    \item \textbf{Query at time $t$:}
        \begin{enumerate}
        \item Find closest checkpoint before $t$
        \item Apply updates from checkpoint to $t$
        \item Answer query, then rollback
        \end{enumerate} \vfill
    \end{itemize}
    
    \note[item]{State Theorem 05 from Demaine, Iacono and Langerman 2007}
    \note[item]{Emphasize the persistent data structure requirement, this is the key limitation}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Explain square-root decomposition concept: break timeline into $\sqrt{m}$ blocks}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Show how queries work: find checkpoint, apply updates, rollback}
    \note[item]{Time complexity: $O(\sqrt{m})$ slowdown per operation}
    \note[item]{Space complexity: $O(m)$ using persistent data structures}
    \note[item]{Set up the problem: what if we don't have persistent version?}
    \note[item]{Key insight: persistent data structures are complex to implement}
    \note[item]{Our contribution: same performance without persistence requirement}
    
\end{frame}

%-------------------------------------------------
% The Space Problem
%-------------------------------------------------
\begin{frame}
    \frametitle{The space problem}
    
    \begin{itemize}
    \item \textbf{Naive approach:} Keep $\sqrt{m}$ independent copies \vfill
    \item Space usage: $\Theta(m\sqrt{m})$ \vfill\pause
    \item \textbf{Demaine et al. solution:} Use persistent data structures \vfill
    \item Space usage: $\Oh(m)$ \vfill\pause
    \end{itemize}
    
    \begin{alertblock}{Problem}
        What if we don't have or don't want to use persistent data structures?
    \end{alertblock} \pause
    
    \begin{block}{Our contribution}
        Simple rebuilding strategy without persistent data structures
        \begin{itemize}
        \item Same time complexity: $\Oh(\sqrt{m})$ per operation
        \item Space usage: $\Theta(m\sqrt{m})$
        \end{itemize}
    \end{block}
    
    \note[item]{Explain the space issue with naive approach: $\Theta(m\sqrt{m})$ space}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Show how Demaine et al. solve it with persistent data structures: O\(m\) space}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{State the practical problem: persistent versions are complex to implement}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Present our key contribution: same performance without persistence}
    \note[item]{Emphasize the space trade-off we make: $\Theta(m\sqrt{m})$ vs O\(m\)}
    \note[item]{This motivates our rebuilding approach}
    \note[item]{Key insight: we can achieve same time complexity with simpler implementation}
    \note[item]{Our approach: use independent copies instead of persistent structures}
    
\end{frame}

%-------------------------------------------------
% Starting Point
%-------------------------------------------------
\begin{frame}
    \frametitle{Starting point}
    
    \begin{itemize}
    \item \textbf{Junior \& Seabra's solution:} Semi-retroactive incremental MSF \vfill
    \item \textbf{Operations:}
        \begin{itemize}
        \item \texttt{add\_edge}$(u,v,w,t)$: add edge at time $t$
        \item \texttt{get\_msf}$(t)$: get MSF at time $t$
        \end{itemize} \vfill\pause
    \item \textbf{Implementation:} Square-root decomposition \vfill
    \item \textbf{Checkpoints:} $t_i = i\sqrt{m}$ for $i = 1,\ldots,\sqrt{m}$ \vfill\pause
    \item \textbf{Data structures:} $D_i$ contains edges before time $t_i$ \vfill
    \item \textbf{Time:} $\Oh(\sqrt{m}\log n)$ per operation \vfill
    \end{itemize}
    
    \note[item]{Start with Junior and Seabra's work as our starting point}
    \note[item]{Explain their semi-retroactive MSF problem: add edge at time t, query at time t}
    \note[item]{Show their operations: add\_edge\(u,v,w,t\) and get\_msf\(t\)}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Describe their square-root decomposition approach: $\sqrt{m}$ checkpoints}
    \note[item]{Show how they use checkpoints: $t_i = i \sqrt{m} for i = 1,...,sqrt{m}$}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Data structures: $D_i$ contains edges before time $t_i$}
    \note[item]{Time complexity: $O(\sqrt{m} log n)$ per operation}
    \note[item]{This sets up their limitations in the next slide}
    \note[item]{Key insight: they assume fixed m and time range - serious restrictions}
    
\end{frame}

%-------------------------------------------------
% Limitations of Junior & Seabra
%-------------------------------------------------
\begin{frame}
    \frametitle{Limitations}
    
    \begin{alertblock}{Problems with their approach}
        \begin{itemize}
        \item \textbf{Fixed $m$:} Must know sequence length beforehand
        \item \textbf{Fixed time range:} Operations must have timestamps $1$ to $m$
        \item \textbf{No rebuilding:} Cannot handle arbitrary growth
        \end{itemize}
    \end{alertblock} \pause
    
    \begin{block}{Our goal}
        Remove these limitations while maintaining efficiency
    \end{block} \pause
    
    \begin{itemize}
    \item \textbf{Key insight:} Implement rebuilding process \vfill
    \item \textbf{Challenge:} How to rebuild without persistent data structures? \vfill
    \item \textbf{Solution:} Reuse existing data structures during rebuilding \vfill
    \end{itemize}
    
    \note[item]{Clearly list their three main limitations}
    \note[item]{Emphasize that fixed m and time range are serious restrictions}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{State our goal: remove these limitations while maintaining efficiency}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Present our key insight: implement rebuilding process}
    \note[item]{Explain the challenge: how to rebuild without persistent structures}
    \note[item]{This motivates our solution in the next slide}
    \note[item]{Key insight: we need to handle arbitrary growth without knowing m beforehand}
    \note[item]{Our approach: rebuild when m becomes a perfect square}
    
\end{frame}

%-------------------------------------------------
% Our Solution - Rebuilding Strategy
%-------------------------------------------------
\begin{frame}
    \frametitle{Our solution - Rebuilding strategy}
    
    \begin{itemize}
    \item \textbf{Key idea:} Reuse existing data structures during rebuilding \vfill
    \item \textbf{Rebuilding moments:} When $m = k^2$ (perfect square) \vfill\pause
    \item \textbf{Strategy:}
        \begin{enumerate}
        \item Create new empty structures $D'_0, D'_1$
        \item Reuse $D_i \rightarrow D'_{i+2}$ for $i = 0,\ldots,k-1$
        \item Apply missing updates to each $D'_i$
        \end{enumerate} \vfill\pause
    \end{itemize}
    
    \begin{block}{Key Lemma}
        Every update in $D_i$ is within the first $(i+2)(k+1)$ updates in the new sequence.
    \end{block} \pause
    
    \begin{itemize}
    \item \textbf{Time per rebuilding:} $\Oh(m\log n)$ \vfill
    \item \textbf{Amortized cost:} $\Oh(\sqrt{m}\log n)$ per operation \vfill
    \end{itemize}
    
    \note[item]{Explain our key insight: reuse existing data structures}
    \note[item]{Show rebuilding moments: when $m$ is a perfect square $(m = k^2)$}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Walk through the three-step strategy:}
    \note[item]{1. Create new empty structures $D'_0, D'_1$}
    \note[item]{2. Reuse $D_i to D'_{i+2}$ for $i = 0,...,k-1$}
    \note[item]{3. Apply missing updates to each $D'_i$}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Present the key lemma: every update in $D_i$ is within first $(i+2)(k+1)$ updates}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Analyze time complexity: $O(m log n)$ total, $O(\sqrt{m} log n)$ amortized}
    \note[item]{This sets up the detailed algorithm in the next slide}
    \note[item]{Key insight: we can reuse most of the work from previous structures}
    \note[item]{The offset (i+2) is crucial for correctness}
    
\end{frame}

%-------------------------------------------------
% Rebuilding Algorithm
%-------------------------------------------------
\begin{frame}
    \frametitle{Rebuilding algorithm}
    
    \begin{enumerate}
        \item $D'_0 \gets$ \textsc{newIncrementalMSF}()
        \item $D'_1 \gets$ \textsc{newIncrementalMSF}()
        \item For $i = 2$ to $k+1$: $D'_i \gets D_{i-2}$ \hfill {\footnotesize $\rhd$ reuse existing}
        \item For $i = 1$ to $k+1$:
        \begin{itemize}
        \item $p \gets$ \textsc{kth}$(S, i(k+1))$ \hfill {\footnotesize $\rhd$ $i(k+1)$th edge}
        \item $t'_i \gets p.\text{time}$
        \item \textsc{addEdges}$(S, t_{i-2}, t'_i, D'_i)$
        \end{itemize}
        \item Return $k+1, D', t'$
    \end{enumerate} \pause
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Original checkpoints
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D0) at (2, 2) {$D_0$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D1) at (4, 2) {$D_1$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D2) at (6, 2) {$D_2$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D3) at (8, 2) {$D_3$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D4) at (10, 2) {$D_4$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D5) at (12, 2) {$D_5$};
            
            % New checkpoints
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=blue!20] (D0new) at (0, 0) {$D'_0$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=blue!20] (D1new) at (2, 0) {$D'_1$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D2new) at (4, 0) {$D'_2$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D3new) at (6, 0) {$D'_3$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D4new) at (8, 0) {$D'_4$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D5new) at (10, 0) {$D'_5$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D6new) at (12, 0) {$D'_6$};
            
            % Arrows showing reuse
            \draw[->, thick, red] (D0.south) -- (D2new.north);
            \draw[->, thick, red] (D1.south) -- (D3new.north);
            \draw[->, thick, red] (D2.south) -- (D4new.north);
            \draw[->, thick, red] (D3.south) -- (D5new.north);
            \draw[->, thick, red] (D4.south) -- (D6new.north);
            
            % Labels
            \node at (0, 3) {\small Original};
            \node at (0, -1) {\small New};
            \node at (6, -1.5) {\small $D_i \rightarrow D'_{i+2}$};
        \end{tikzpicture}
        \caption{Rebuilding: Reuse existing data structures with offset}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{Key insight:} Reuse $D_i \rightarrow D'_{i+2}$ \vfill
    \item \textbf{Time:} $\Oh(m\log n)$ total, $\Oh(\sqrt{m}\log n)$ amortized \vfill
    \item \textbf{Space:} $\Theta(m\sqrt{m})$ \vfill
    \end{itemize}
    
    \note[item]{Show the step-by-step rebuilding algorithm}
    \note[item]{Explain how we create new empty structures $D'_0$, $D'_1$}
    \note[item]{Show how we reuse existing structures with offset: $D_i$ becomes $D'_{i+2}$}
    \note[item]{Walk through the process of applying missing updates}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Explain the key insight: $D_i$ becomes $D'_{i+2}$ with offset}
    \note[item]{Analyze time complexity: $O(m log n)$ total, $O(\sqrt{m} log n)$ amortized}
    \note[item]{Space complexity: $\Theta(m\sqrt{m})$ - this is our trade-off}
    \note[item]{This leads to our results in the next slide}
    \note[item]{Key insight: the algorithm is surprisingly simple despite its power}
    \note[item]{The visual shows the reuse pattern clearly}
    
\end{frame}

%-------------------------------------------------
% Results
%-------------------------------------------------
\begin{frame}
    \frametitle{Results}
    
    \begin{block}{Our contribution}
        \begin{itemize}
        \item \textbf{General transformation:} Partial $\rightarrow$ Full retroactivity \vfill
        \item \textbf{No persistent data structures needed} \vfill
        \item \textbf{Same time complexity:} $\Oh(\sqrt{m})$ per operation \vfill
        \item \textbf{Space trade-off:} $\Theta(m\sqrt{m})$ vs $\Oh(m)$ \vfill
        \end{itemize}
    \end{block} \pause
    
    \begin{block}{Semi-retroactive MSF implementation}
        \begin{itemize}
        \item \textbf{Operations:} \texttt{add\_edge}$(u,v,w,t)$, \texttt{get\_msf}$(t)$ \vfill
        \item \textbf{Time:} $\Oh(\sqrt{m}\log n)$ per operation \vfill
        \item \textbf{Space:} $\Theta(m\sqrt{m})$ \vfill
        \item \textbf{No fixed $m$ or time range restrictions} \vfill
        \end{itemize}
    \end{block}
    
    \note[item]{Summarize our main theoretical contribution}
    \note[item]{Emphasize that we don't need persistent data structures - this is the key advantage}
    \note[item]{Show we achieve the same time complexity as Demaine et al.: O\(\sqrt{m}\) per operation}
    \note[item]{Present our MSF implementation results: O\(\sqrt{m} log n\) per operation}
    \note[item]{Highlight that we removed the fixed m and time range restrictions}
    \note[item]{This demonstrates the practical value of our approach}
    \note[item]{Key insight: we provide a simpler alternative to persistent data structures}
    \note[item]{Space trade-off: Theta\(m\sqrt{m}\)vs O\(m\) - but much simpler implementation}
    \note[item]{Our approach is more practical for many applications}
    
\end{frame}

%-------------------------------------------------
% Extending for Full Retroactivity
%-------------------------------------------------
\begin{frame}
    \frametitle{Extending for full retroactivity}
    
    \begin{itemize}
    \item \textbf{General applicability:} Works for any partially retroactive data structure \vfill\pause
    \item \textbf{Supporting removals:} To achieve full retroactivity \vfill
        \begin{itemize}
        \item Adapt rebuilding trigger: when $|\lfloor\sqrt{m'}\rfloor - \lfloor\sqrt{m}\rfloor| \leq 1$
        \item Handle both insertions and removals in update sequence
        \item Rebuilding frequency: every $2\lfloor\sqrt{m}\rfloor-1$ operations
        \end{itemize} \vfill\pause
    \item \textbf{Requirements:}
        \begin{itemize}
        \item Partially retroactive data structure
        \item Rollback capability
        \item No persistent version needed
        \end{itemize} \vfill
    \end{itemize}
    
    \note[item]{Emphasize the general applicability of our approach}
    \note[item]{Explain how to extend for full retroactivity with removals}
    \note[item]{Show the adapted rebuilding trigger condition}
    \note[item]{Explain how to handle both insertions and removals}
    \note[item]{List the requirements: partially retroactive, rollback capability}
    \note[item]{This shows how our approach can be extended for full functionality}
    \note[item]{Key insight: our method works for any partially retroactive data structure}
    \note[item]{The rebuilding frequency changes but the core idea remains the same}
    \note[item]{This demonstrates the generality of our approach}
    
\end{frame}

%-------------------------------------------------
% SLIDE: Thank You
%-------------------------------------------------
\begin{frame}
    \begin{center}
        \Huge{Thank you! \ \vfill Questions?}
    \end{center}
    
    \note[item]{Invite questions from the audience}
    \note[item]{Be prepared to answer questions about:}
          \note[item]{* The rebuilding algorithm details}
          \note[item]{* Space vs time trade-offs}
          \note[item]{* Implementation challenges}
          \note[item]{* Comparison with persistent data structures}
          \note[item]{* Applications beyond MSF}
    \note[item]{Key points to emphasize if asked:}
          \note[item]{* Our approach is simpler to implement}
          \note[item]{* Same time complexity as Demaine et al.}
          \note[item]{* No persistent data structure requirement}
          \note[item]{* General applicability to any partially retroactive structure}
    \note[item]{Thank the audience for their attention}
    
\end{frame}

\end{document}