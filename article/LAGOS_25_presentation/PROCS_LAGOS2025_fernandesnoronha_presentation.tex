%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LaTeX Beamer Presentation (Condensed Version)
%
% On-s minimal.
% Speaker notes are included as comments (%) in each frame.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[fleqn]{beamer}

\usepackage[utf8]{inputenc}
\setlength{\mathindent}{\parindent}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx} 
\usepackage{pifont}
\usepackage{cancel}
\usepackage{tikz}
\usetikzlibrary{calc,positioning,decorations.pathmorphing,decorations.pathreplacing}
\usetikzlibrary{backgrounds}
\usepackage{./figstyle}
\usepackage{algorithm}
\usepackage{algpseudocode}

\newcommand{\greencheck}{\textbf{\textcolor{green}{\ding{51}}}}
\newcommand{\Oh}{\mathcal{O}}

%------------------------------------------------------------
% Theme and Color Scheme
%------------------------------------------------------------
\usetheme{Boadilla}

\usecolortheme{default}

\pdfstringdefDisableCommands{%
  \def\\{}%
  \def\texttt#1{<#1>}%
  \def\vspace#1{}%
}

%------------------------------------------------------------
% Presentation Information
%------------------------------------------------------------
\title[Partial to full retroactivity]{How to go from partial to full retroactivity in detail}
\author[Felipe C. Noronha]{Cristina Gomes Fernandes, Felipe Castro de Noronha}
\institute[IME-USP]{
    IME-USP -- Brazil
}
\date{LAGOS 25 -- November 10-14, 2025}

%------------------------------------------------------------
% The Presentation Begins
%------------------------------------------------------------
\begin{document}

%-------------------------------------------------
% Title Page
%-------------------------------------------------
\begin{frame}
    \titlepage
    \note{
        - Introduce yourself: Cristina Gomes Fernandes (IME-USP) and Felipe Castro de Noronha
        - State topic: going from partial to full retroactivity in detail
        - This work addresses a practical limitation in Demaine, Iacono & Langerman's 2007 transformation
        - Our contribution: same time complexity without requiring persistent data structures
        - Secondary contribution: implementation of semi-retroactive incremental MSF
        - Key insight: we can reuse existing data structures during rebuilding process
    }
\end{frame}


%-------------------------------------------------
% What is a Spanning Tree?
%-------------------------------------------------
\begin{frame}
    \frametitle{What is a spanning tree?}
    
    \begin{itemize}
    \item Let $G = (V, E)$ be a connected graph \vfill
    \item \textbf{Spanning tree:} A tree with all vertices of $G$ \vfill\pause
    \item \textbf{Properties:}
        \begin{itemize}
        \item Connected (path between any two vertices)
        \item Acyclic (no cycles)
        \item Contains exactly $n-1$ edges for $n$ vertices
        \end{itemize} \vfill\pause
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Graph G edges (blue straight lines - edges NOT in T)
            \draw[blue, thick] (A) -- (B);  % AB
            \draw[blue, thick] (F) -- (G);  % FG
            \draw[blue, thick] (F) -- (D);  % FD
            \draw[blue, thick] (H) -- (D);  % HD  
            \draw[blue, thick] (C) -- (F);  % CF
            \draw[blue, thick] (G) -- (H);  % GH
            
            % Spanning tree T edges (red wavy lines)
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A);  % CA
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F);  % AF
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (D);  % AD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (D);  % GD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (D);  % BD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (E);  % BE
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (H) -- (E);  % HE
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {T};
        \end{tikzpicture}
        \caption{Graph $G$ (blue edges) and spanning tree $T$ (red wavy edges)}
    \end{figure}
    
    \note{
        - Start with basic concept of spanning tree - fundamental in graph theory
        - Show visual example with graph G (blue edges) and spanning tree T (red wavy edges)
        - Explain key properties: connected (path between any two vertices), acyclic (no cycles), contains exactly n-1 edges for n vertices
        - In the example: 8 vertices, so spanning tree has exactly 7 edges
        - This builds up the concepts step by step for the incremental MSF problem
        - Emphasize that spanning trees are not unique - there can be many valid spanning trees
    }
\end{frame}


%-------------------------------------------------
% Minimum Spanning Tree and Forest
%-------------------------------------------------
\begin{frame}
    \frametitle{Minimum Spanning Tree and Forest}
    
    \begin{itemize}
    \item \textbf{Minimum Spanning Tree (MST):} spanning tree with minimum total cost \vfill\pause
    \item \textbf{Minimum Spanning Forest (MSF):} generalization for disconnected graphs \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Graph G edges (blue straight lines - edges NOT in MST)
            \draw[blue, thick] (A) -- (B) node[midway, above=0.1cm, font=\small] {8};  % AB
            \draw[blue, thick] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};  % FG
            \draw[blue, thick] (F) -- (D) node[midway, left=0.1cm, font=\small] {7};  % FD
            \draw[blue, thick] (H) -- (D) node[midway, right=0.1cm, font=\small] {9};  % HD  
            \draw[blue, thick] (C) -- (F) node[midway, left=0.1cm, font=\small] {5};  % CF
            \draw[blue, thick] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};  % GH
            
            % MST edges (red wavy lines) - with weights that make it minimum
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};  % CA
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};  % AF
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (D) node[midway, above=0.1cm, font=\small] {3};  % AD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (D) node[midway, right=0.1cm, font=\small] {2};  % GD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (D) node[midway, above=0.1cm, font=\small] {3};  % BD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (E) node[midway, right=0.1cm, font=\small] {1};  % BE
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (H) -- (E) node[midway, right=0.1cm, font=\small] {2};  % HE
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MST};
        \end{tikzpicture}
        \caption{Graph $G$ (blue edges) and Minimum Spanning Tree (red wavy edges)}
    \end{figure}

    \note{
        - Define MST as spanning tree with minimum total cost - optimization problem
        - Show visual example with weighted edges: blue edges show graph G, red wavy edges show MST
        - Demonstrate that red edges form MST with cost 14 (1+2+3+2+3+1+2 = 14)
        - Explain that any other spanning tree would have higher cost - this is the optimal solution
        - Generalize to MSF for disconnected graphs - collection of MSTs for each component
        - This prepares for the incremental MSF problem where we maintain optimality dynamically
        - Key insight: we need to maintain optimality as edges are added one by one
    }
\end{frame}

%-------------------------------------------------
% Incremental MSF Problem
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF problem}
    
    \begin{itemize}
    \item \textbf{Problem:} Keep track of an MSF in a graph that grows over time \vfill
    \item Graph starts empty, edges are added one by one \vfill\pause
    \item \textbf{Operations:}
        \begin{itemize}
        \item \texttt{add\_edge}$(u,v,w)$: add edge with cost $w$ between vertices $u$ and $v$
        \item \texttt{get\_msf}(): return a list with the edges of an MSF of $G$
        \end{itemize} \vfill\pause
    \item \textbf{Solution:} Frederickson (1983) using link-cut trees \vfill
    \end{itemize}
    \note{
        - Define incremental MSF problem clearly: maintain MSF as graph grows
        - Emphasize that graph starts empty and grows - this is crucial for our approach
        - Show the two key operations: add_edge(u,v,w) and get_msf()
        - Mention Frederickson's breakthrough solution from 1983 using link-cut trees
        - Note the cost is O(log n) amortized per edge addition using link-cut trees
        - This is the foundation for retroactive version - we'll extend this to handle time
        - Key insight: we need to maintain MSF not just for current state, but for any time t
    }
\end{frame}

%-------------------------------------------------
% Frederickson's Link-Cut Tree Solution
%-------------------------------------------------
\begin{frame}
    \frametitle{Frederickson's link-cut tree solution}
    
    \begin{itemize}
    \item \textbf{Key insight:} Use link-cut trees to maintain MSF dynamically \vfill\pause
    \item \textbf{Algorithm for adding edge $(u,v,w)$:}
        \begin{enumerate}
        \item Check if $u$ and $v$ are in same component
        \item If not: add edge to forest
        \item If yes: find max cost edge on $u$-$v$ path
        \item If $w < \text{max cost}$: replace max edge with new edge
        \end{enumerate} \vfill\pause
    \item \textbf{Link-cut tree operations:}
        \begin{itemize}
        \item \texttt{find\_max}$(u,v)$: $\Oh(\log n)$ amortized
        \item \texttt{link}$(u,v)$: $\Oh(\log n)$ amortized
        \item \texttt{cut}$(u,v)$: $\Oh(\log n)$ amortized
        \end{itemize} \vfill\pause
    \item \textbf{Total cost:} Amortized $\Oh(\log n)$ per edge addition \vfill
    \end{itemize}
    \note{
        - Explain Frederickson's key insight: use link-cut trees to maintain MSF dynamically
        - Walk through the algorithm step by step:
          1. Check connectivity using link-cut trees (find_root operations)
          2. If not connected: add edge directly (link operation)
          3. If connected: find max cost edge on u-v path (find_max operation)
          4. If new edge cheaper: replace max edge (cut + link operations)
        - Show how cycle detection and edge replacement works using link-cut tree properties
        - List the specific link-cut tree operations: find_max, link, cut - all O(log n) amortized
        - Emphasize the logarithmic time complexity: O(log n) per edge addition
        - This provides technical foundation for retroactive version - we'll need rollback capability
        - Key insight: link-cut trees support efficient rollback, which we'll need for retroactivity
    }
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 1
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 1}
    
    \begin{itemize}
    \item \textbf{add\_edge(g, h, 4):} Add edge with cost 4 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edge 1: G-H
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 1: Added edge (g,h) with cost 4}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h\} \vfill
    \end{itemize}
    \note{
        - Show first edge being added: (g,h) with cost 4
        - Explain it's automatically added to MSF since no cycle exists yet
        - Current MSF: {g-h} with total cost 4
        - This demonstrates the incremental nature: we start with empty graph
        - Each step shows how MSF evolves as edges are added
        - Link-cut tree operations: link(g,h) - O(log n) time
    }
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 2
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 2}
    
    \begin{itemize}
    \item \textbf{add\_edge(c, a, 1):} Add edge with cost 1 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edges 1-2
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 2: Added edge (c,a) with cost 1}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a\} \vfill
    \end{itemize}
    \note{
        - Show second edge being added: (c,a) with cost 1
        - Still no cycle, so added to MSF directly
        - Current MSF: {g-h, c-a} with total cost 5
        - Link-cut tree operations: link(c,a) - O(log n) time
        - We now have two separate components: {g,h} and {c,a}
        - This shows how MSF grows incrementally without cycles
    }
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 3
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 3}
    
    \begin{itemize}
    \item \textbf{add\_edge(f, g, 6):} Add edge with cost 6 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edges 1-3
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 3: Added edge (f,g) with cost 6}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g\} \vfill
    \end{itemize}
    \note{
        - Show third edge being added: (f,g) with cost 6
        - Still no cycle, so added to MSF directly
        - Current MSF: {g-h, c-a, f-g} with total cost 11
        - Link-cut tree operations: link(f,g) - O(log n) time
        - Now we have components: {g,h,f} and {c,a}
        - This continues the incremental growth pattern
    }
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 4
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 4}
    
    \begin{itemize}
    \item \textbf{add\_edge(a, f, 2):} Add edge with cost 2 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edges 1-4
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 4: Added edge (a,f) with cost 2}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g, a-f\} \vfill
    \end{itemize}
    \note{
        - Show fourth edge being added: (a,f) with cost 2
        - Still no cycle, so added to MSF directly
        - Current MSF: {g-h, c-a, f-g, a-f} with total cost 13
        - Link-cut tree operations: link(a,f) - O(log n) time
        - Now we have components: {g,h,f,a,c} - all vertices connected!
        - This shows how components merge as edges are added
    }
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 5
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 5}
    
    \begin{itemize}
    \item \textbf{add\_edge(c, f, 5):} Add edge with cost 5 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edge NOT in MSF
            \draw[blue, thick] (C) -- (F) node[midway, above=0.1cm, font=\small] {5};  % CF

            % Edges 1-5
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 5: Added edge (c,f) with cost 5}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g, a-f\} \vfill
    \end{itemize}
    \note{
        - Show fifth edge being added: (c,f) with cost 5
        - This creates a cycle! c-a-f-g-h-c forms a cycle
        - Link-cut tree operations: find_max(c,f) finds edge (f,g) with cost 6
        - Since new edge cost 5 < max cost 6, we replace (f,g) with (c,f)
        - Current MSF: {g-h, c-a, c-f, a-f} with total cost 12 (improved!)
        - This demonstrates the cycle-breaking optimization in Frederickson's algorithm
        - Key insight: we maintain optimality by replacing expensive edges with cheaper ones
    }
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 6
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 6}
    
    \begin{itemize}
    \item \textbf{add\_edge(f, d, 7):} Add edge with cost 7 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edge NOT in MSF
            \draw[blue, thick] (C) -- (F) node[midway, above=0.1cm, font=\small] {5};  % CF

            % Edges 1-6
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (D) node[midway, left=0.1cm, font=\small] {7};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 6: Added edge (f,d) with cost 7}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g, a-f, f-d\} \vfill
    \end{itemize}
    \note{
        - Show sixth edge being added: (f,d) with cost 7
        - This creates a cycle! f-d-g-h-f forms a cycle
        - Link-cut tree operations: find_max(f,d) finds edge (g,h) with cost 4
        - Since new edge cost 7 > max cost 4, we don't replace - edge is rejected
        - Current MSF: {g-h, c-a, c-f, a-f} with total cost 12 (unchanged)
        - This shows how expensive edges are rejected to maintain optimality
        - Key insight: not all edges improve the MSF - we only keep beneficial ones
    }
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 7
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 7}
    
    \begin{itemize}
    \item \textbf{add\_edge(a, d, 3):} Add edge with cost 3 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};

            % Edge NOT in MSF
            \draw[blue, thick] (C) -- (F) node[midway, above=0.1cm, font=\small] {5};  % CF
            \draw[blue, thick] (F) -- (D) node[midway, above=0.1cm, font=\small] {7};  % FD
            
            % Edges 1-7
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (D) node[midway, left=0.1cm, font=\small] {3};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 7: Added edge (a,d) with cost 3}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g, a-f, a-d\} \vfill
    \end{itemize}
    \note{
        - Show seventh edge being added: (a,d) with cost 3
        - This creates a cycle! a-d-f-c-a forms a cycle
        - Link-cut tree operations: find_max(a,d) finds edge (c,f) with cost 5
        - Since new edge cost 3 < max cost 5, we replace (c,f) with (a,d)
        - Current MSF: {g-h, c-a, a-d, a-f} with total cost 10 (improved!)
        - This shows continued optimization as better edges are found
        - Key insight: the algorithm continuously improves the MSF as new edges arrive
    }
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 8
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 8}
    
    \begin{itemize}
    \item \textbf{add\_edge(d, g, 2):} Add edge with cost 2 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};

            % Edge NOT in MSF
            \draw[blue, thick] (C) -- (F) node[midway, above=0.1cm, font=\small] {5};  % CF
            \draw[blue, thick] (F) -- (D) node[midway, above=0.1cm, font=\small] {7};  % FD
            \draw[blue, thick] (F) -- (G) node[midway, above=0.1cm, font=\small] {6};  % FG
            
            % Edges 1-7
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (D) -- (G) node[midway, right=0.1cm, font=\small] {2};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (D) node[midway, left=0.1cm, font=\small] {3};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 8: Added edge (d,g) with cost 2}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, a-f, a-d, d-g\} \vfill
    \end{itemize}
    \note{
        - Show eighth edge being added: (d,g) with cost 2
        - This creates a cycle! d-g-h-f-a-d forms a cycle
        - Link-cut tree operations: find_max(d,g) finds edge (g,h) with cost 4
        - Since new edge cost 2 < max cost 4, we replace (g,h) with (d,g)
        - Current MSF: {d-g, c-a, a-d, a-f} with total cost 8 (improved!)
        - This shows the final optimization step
        - Key insight: the algorithm finds the optimal MSF through incremental improvements
        - Total cost reduced from 14 to 8 through smart edge replacements
    }
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Final Result
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Final Result}
    
    \begin{itemize}
    \item \textbf{Continue adding edges...} \vfill\pause
    \item \textbf{Final MSF:} Minimum spanning forest with optimal cost \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Graph G edges (blue straight lines - edges NOT in MST)
            \draw[blue, thick] (A) -- (B) node[midway, above=0.1cm, font=\small] {8};  % AB
            \draw[blue, thick] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};  % FG
            \draw[blue, thick] (A) -- (D) node[midway, above=0.1cm, font=\small] {3};  % AD
            \draw[blue, thick] (H) -- (D) node[midway, right=0.1cm, font=\small] {9};  % HD  
            \draw[blue, thick] (C) -- (F) node[midway, left=0.1cm, font=\small] {5};  % CF
            \draw[blue, thick] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};  % GH
            
            % MST edges (red wavy lines) - with weights that make it minimum
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};  % CA
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};  % AF
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (D) node[midway, left=0.1cm, font=\small] {1};  % FD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (D) node[midway, right=0.1cm, font=\small] {2};  % GD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (D) node[midway, above=0.1cm, font=\small] {3};  % BD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (E) node[midway, right=0.1cm, font=\small] {1};  % BE
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (H) -- (E) node[midway, right=0.1cm, font=\small] {2};  % HE
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Final MSF with optimal cost = 12}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{Solution:} Frederickson (1983) using link-cut trees \vfill
    \end{itemize}
    \note{
        - Show final complete MSF with optimal cost = 12
        - Summarize the incremental process: started empty, added edges one by one
        - Transition to Frederickson's solution: O(log n) amortized per edge addition
        - Key insight: link-cut trees enable efficient cycle detection and edge replacement
        - This sets up the retroactive version: what if we want to query MSF at any time t?
        - The challenge: maintain MSF not just for current state, but for any historical time
        - This motivates the need for retroactive data structures
    }
\end{frame}

%-------------------------------------------------
% What is Retroactivity?
%-------------------------------------------------
\begin{frame}
    \frametitle{What is retroactivity?}
    
    \begin{itemize}
    \item \textbf{Problem:} Data structures usually support updates and queries \vfill
    \item Order of updates affects the state of the data structure \vfill\pause
    \item \textbf{Retroactivity:} Manipulate the sequence of updates \vfill\pause
    \item \textbf{Operations:}
        \begin{itemize}
        \item Insert update at time $t$ (possibly in the past)
        \item Remove update at time $t$
        \item Query at time $t$ (not just present)
        \end{itemize} \vfill
    \end{itemize}
    \note{
        - Start with the fundamental problem: data structures depend on update order
        - Explain the motivation: correcting mistakes, adding forgotten operations
        - Show the three key operations: insert, remove, query at any time
        - Make it clear that query at any time is crucial for full retroactivity
        - Emphasize that time stamps must be distinct - this is important for correctness
        - Give concrete example: MSF at time t = 5 vs MSF at time t = 10
        - This sets up the distinction between partial and full retroactivity
        - Key insight: we need to maintain state at every possible time, not just current
    }
\end{frame}

%-------------------------------------------------
% Partial vs Full Retroactivity
%-------------------------------------------------
\begin{frame}
    \frametitle{Partial vs Full retroactivity}
    
    \begin{block}{Partially Retroactive}
        \begin{itemize}
        \item Queries only on \textbf{current} state
        \item Insert/remove updates at any time
        \item Example: Dynamic MSF $\rightarrow$ Partially retroactive MSF
        \end{itemize}
    \end{block} \pause
    
    \begin{block}{Fully Retroactive}
        \begin{itemize}
        \item Queries at \textbf{any} time $t$
        \item Insert/remove updates at any time
        \item Complete retroactive functionality
        \end{itemize}
    \end{block} \pause
    
    \begin{block}{Semi-Retroactive}
        \begin{itemize}
        \item Queries at \textbf{any} time $t$
        \item Insert updates at any time
        \item \textbf{No removal} of updates
        \end{itemize}
    \end{block}
    \note{
        - Clearly distinguish between partial, full, and semi-retroactivity
        - Emphasize that partial only allows queries on current state - this is the limitation
        - Show that full allows queries at any time - much more powerful and useful
        - Define semi-retroactive: queries at any time, insertions, but no removals
        - Give concrete example: dynamic MSF becomes partially retroactive MSF
        - This sets up the challenge: how do we go from partial to full?
        - Key insight: the main difficulty is supporting queries at any time, not just current
        - Our work addresses this challenge with a practical solution
    }
\end{frame}

%-------------------------------------------------
% The Challenge
%-------------------------------------------------
\begin{frame}
    \frametitle{The challenge}
    
    \begin{alertblock}{Challenge}
        How to transform partial $\rightarrow$ full retroactivity?
    \end{alertblock} \pause
    
    \begin{itemize}
    \item \textbf{Problem:} Need to support queries at any time $t$ \vfill
    \item \textbf{Solution approach:} Square-root decomposition \vfill\pause
    \item \textbf{Key insight:} Keep checkpoints with data structure states \vfill
    \item \textbf{Implementation:} Demaine, Iacono \& Langerman (2007) \vfill
    \end{itemize}
    \note{
        - State the main challenge clearly: partial → full retroactivity
        - Explain what we need to achieve: queries at any time t
        - Introduce the solution approach: square-root decomposition
        - Mention the key insight about checkpoints
        - Reference the Demaine et al. work from 2007
        - This motivates the detailed solution in the next slide
        - Key insight: we need to maintain multiple versions of the data structure
        - The challenge: how to do this efficiently without persistent data structures?
    }
\end{frame}

%-------------------------------------------------
% Demaine, Iacono & Langerman's Solution
%-------------------------------------------------
\begin{frame}
    \frametitle{Demaine, Iacono \& Langerman's solution}
    
    \begin{theorem}[Theorem 05]
        Any partially retroactive data structure can be transformed into a fully retroactive one with:
        \begin{itemize}
        \item $\Oh(\sqrt{m})$ slowdown per operation
        \item $\Oh(m)$ space usage
        \item \textbf{Requirement:} Need persistent version of the data structure
        \end{itemize}
    \end{theorem} \pause
    
    \begin{itemize}
    \item \textbf{Key idea:} Square-root decomposition \vfill
    \item Keep $\sqrt{m}$ checkpoints with data structure states \vfill\pause
    \item \textbf{Query at time $t$:}
        \begin{enumerate}
        \item Find closest checkpoint before $t$
        \item Apply updates from checkpoint to $t$
        \item Answer query, then rollback
        \end{enumerate} \vfill
    \end{itemize}
    \note{
        - State Theorem 05 from Demaine, Iacono & Langerman 2007
        - Emphasize the persistent data structure requirement - this is the key limitation
        - Explain square-root decomposition concept: break timeline into √m blocks
        - Show how queries work: find checkpoint, apply updates, rollback
        - Time complexity: O(√m) slowdown per operation
        - Space complexity: O(m) using persistent data structures
        - Set up the problem: what if we don't have persistent version?
        - Key insight: persistent data structures are complex to implement
        - Our contribution: same performance without persistence requirement
    }
\end{frame}

%-------------------------------------------------
% The Space Problem
%-------------------------------------------------
\begin{frame}
    \frametitle{The space problem}
    
    \begin{itemize}
    \item \textbf{Naive approach:} Keep $\sqrt{m}$ independent copies \vfill
    \item Space usage: $\Theta(m\sqrt{m})$ \vfill\pause
    \item \textbf{Demaine et al. solution:} Use persistent data structures \vfill
    \item Space usage: $\Oh(m)$ \vfill\pause
    \end{itemize}
    
    \begin{alertblock}{Problem}
        What if we don't have or don't want to use persistent data structures?
    \end{alertblock} \pause
    
    \begin{block}{Our contribution}
        Simple rebuilding strategy without persistent data structures
        \begin{itemize}
        \item Same time complexity: $\Oh(\sqrt{m})$ per operation
        \item Space usage: $\Theta(m\sqrt{m})$
        \end{itemize}
    \end{block}
    \note{
        - Explain the space issue with naive approach: Θ(m√m) space
        - Show how Demaine et al. solve it with persistent data structures: O(m) space
        - State the practical problem: persistent versions are complex to implement
        - Present our key contribution: same performance without persistence
        - Emphasize the space trade-off we make: Θ(m√m) vs O(m)
        - This motivates our rebuilding approach
        - Key insight: we can achieve same time complexity with simpler implementation
        - Our approach: use independent copies instead of persistent structures
    }
\end{frame}

%-------------------------------------------------
% Starting Point
%-------------------------------------------------
\begin{frame}
    \frametitle{Starting point}
    
    \begin{itemize}
    \item \textbf{Junior \& Seabra's solution:} Semi-retroactive incremental MSF \vfill
    \item \textbf{Operations:}
        \begin{itemize}
        \item \texttt{add\_edge}$(u,v,w,t)$: add edge at time $t$
        \item \texttt{get\_msf}$(t)$: get MSF at time $t$
        \end{itemize} \vfill\pause
    \item \textbf{Implementation:} Square-root decomposition \vfill
    \item \textbf{Checkpoints:} $t_i = i\sqrt{m}$ for $i = 1,\ldots,\sqrt{m}$ \vfill\pause
    \item \textbf{Data structures:} $D_i$ contains edges before time $t_i$ \vfill
    \item \textbf{Time:} $\Oh(\sqrt{m}\log n)$ per operation \vfill
    \end{itemize}
    \note{
        - Start with Junior & Seabra's work as our starting point
        - Explain their semi-retroactive MSF problem: add edge at time t, query at time t
        - Show their operations: add_edge(u,v,w,t) and get_msf(t)
        - Describe their square-root decomposition approach: √m checkpoints
        - Show how they use checkpoints: t_i = i√m for i = 1,...,√m
        - Data structures: D_i contains edges before time t_i
        - Time complexity: O(√m log n) per operation
        - This sets up their limitations in the next slide
        - Key insight: they assume fixed m and time range - serious restrictions
    }
\end{frame}

%-------------------------------------------------
% Limitations of Junior & Seabra
%-------------------------------------------------
\begin{frame}
    \frametitle{Limitations}
    
    \begin{alertblock}{Problems with their approach}
        \begin{itemize}
        \item \textbf{Fixed $m$:} Must know sequence length beforehand
        \item \textbf{Fixed time range:} Operations must have timestamps $1$ to $m$
        \item \textbf{No rebuilding:} Cannot handle arbitrary growth
        \end{itemize}
    \end{alertblock} \pause
    
    \begin{block}{Our goal}
        Remove these limitations while maintaining efficiency
    \end{block} \pause
    
    \begin{itemize}
    \item \textbf{Key insight:} Implement rebuilding process \vfill
    \item \textbf{Challenge:} How to rebuild without persistent data structures? \vfill
    \item \textbf{Solution:} Reuse existing data structures during rebuilding \vfill
    \end{itemize}
    \note{
        - Clearly list their three main limitations
        - Emphasize that fixed m and time range are serious restrictions
        - State our goal: remove these limitations while maintaining efficiency
        - Present our key insight: implement rebuilding process
        - Explain the challenge: how to rebuild without persistent structures
        - This motivates our solution in the next slide
        - Key insight: we need to handle arbitrary growth without knowing m beforehand
        - Our approach: rebuild when m becomes a perfect square
    }
\end{frame}

%-------------------------------------------------
% Our Solution - Rebuilding Strategy
%-------------------------------------------------
\begin{frame}
    \frametitle{Our solution - Rebuilding strategy}
    
    \begin{itemize}
    \item \textbf{Key idea:} Reuse existing data structures during rebuilding \vfill
    \item \textbf{Rebuilding moments:} When $m = k^2$ (perfect square) \vfill\pause
    \item \textbf{Strategy:}
        \begin{enumerate}
        \item Create new empty structures $D'_0, D'_1$
        \item Reuse $D_i \rightarrow D'_{i+2}$ for $i = 0,\ldots,k-1$
        \item Apply missing updates to each $D'_i$
        \end{enumerate} \vfill\pause
    \end{itemize}
    
    \begin{block}{Key Lemma}
        Every update in $D_i$ is within the first $(i+2)(k+1)$ updates in the new sequence.
    \end{block} \pause
    
    \begin{itemize}
    \item \textbf{Time per rebuilding:} $\Oh(m\log n)$ \vfill
    \item \textbf{Amortized cost:} $\Oh(\sqrt{m}\log n)$ per operation \vfill
    \end{itemize}
    \note{
        - Explain our key insight: reuse existing data structures
        - Show rebuilding moments: when m is a perfect square (m = k²)
        - Walk through the three-step strategy:
          1. Create new empty structures D'_0, D'_1
          2. Reuse D_i → D'_{i+2} for i = 0,...,k-1
          3. Apply missing updates to each D'_i
        - Present the key lemma: every update in D_i is within first (i+2)(k+1) updates
        - Analyze time complexity: O(m log n) total, O(√m log n) amortized
        - This sets up the detailed algorithm in the next slide
        - Key insight: we can reuse most of the work from previous structures
        - The offset (i+2) is crucial for correctness
    }
\end{frame}

%-------------------------------------------------
% Rebuilding Algorithm
%-------------------------------------------------
\begin{frame}
    \frametitle{Rebuilding algorithm}
    
    \begin{enumerate}
        \item $D'_0 \gets$ \textsc{newIncrementalMSF}()
        \item $D'_1 \gets$ \textsc{newIncrementalMSF}()
        \item For $i = 2$ to $k+1$: $D'_i \gets D_{i-2}$ \hfill {\footnotesize $\rhd$ reuse existing}
        \item For $i = 1$ to $k+1$:
        \begin{itemize}
        \item $p \gets$ \textsc{kth}$(S, i(k+1))$ \hfill {\footnotesize $\rhd$ $i(k+1)$th edge}
        \item $t'_i \gets p.\text{time}$
        \item \textsc{addEdges}$(S, t_{i-2}, t'_i, D'_i)$
        \end{itemize}
        \item Return $k+1, D', t'$
    \end{enumerate} \pause
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Original checkpoints
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D0) at (2, 2) {$D_0$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D1) at (4, 2) {$D_1$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D2) at (6, 2) {$D_2$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D3) at (8, 2) {$D_3$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D4) at (10, 2) {$D_4$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D5) at (12, 2) {$D_5$};
            
            % New checkpoints
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=blue!20] (D0new) at (0, 0) {$D'_0$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=blue!20] (D1new) at (2, 0) {$D'_1$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D2new) at (4, 0) {$D'_2$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D3new) at (6, 0) {$D'_3$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D4new) at (8, 0) {$D'_4$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D5new) at (10, 0) {$D'_5$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D6new) at (12, 0) {$D'_6$};
            
            % Arrows showing reuse
            \draw[->, thick, red] (D0.south) -- (D2new.north);
            \draw[->, thick, red] (D1.south) -- (D3new.north);
            \draw[->, thick, red] (D2.south) -- (D4new.north);
            \draw[->, thick, red] (D3.south) -- (D5new.north);
            \draw[->, thick, red] (D4.south) -- (D6new.north);
            
            % Labels
            \node at (0, 3) {\small Original};
            \node at (0, -1) {\small New};
            \node at (6, -1.5) {\small $D_i \rightarrow D'_{i+2}$};
        \end{tikzpicture}
        \caption{Rebuilding: Reuse existing data structures with offset}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{Key insight:} Reuse $D_i \rightarrow D'_{i+2}$ \vfill
    \item \textbf{Time:} $\Oh(m\log n)$ total, $\Oh(\sqrt{m}\log n)$ amortized \vfill
    \item \textbf{Space:} $\Theta(m\sqrt{m})$ \vfill
    \end{itemize}
    \note{
        - Show the step-by-step rebuilding algorithm
        - Explain how we create new empty structures D'_0, D'_1
        - Show how we reuse existing structures with offset: D_i becomes D'_{i+2}
        - Walk through the process of applying missing updates
        - Explain the key insight: D_i becomes D'_{i+2} with offset
        - Analyze time complexity: O(m log n) total, O(√m log n) amortized
        - Space complexity: Θ(m√m) - this is our trade-off
        - This leads to our results in the next slide
        - Key insight: the algorithm is surprisingly simple despite its power
        - The visual shows the reuse pattern clearly
    }
\end{frame}

%-------------------------------------------------
% Results
%-------------------------------------------------
\begin{frame}
    \frametitle{Results}
    
    \begin{block}{Our contribution}
        \begin{itemize}
        \item \textbf{General transformation:} Partial $\rightarrow$ Full retroactivity \vfill
        \item \textbf{No persistent data structures needed} \vfill
        \item \textbf{Same time complexity:} $\Oh(\sqrt{m})$ per operation \vfill
        \item \textbf{Space trade-off:} $\Theta(m\sqrt{m})$ vs $\Oh(m)$ \vfill
        \end{itemize}
    \end{block} \pause
    
    \begin{block}{Semi-retroactive MSF implementation}
        \begin{itemize}
        \item \textbf{Operations:} \texttt{add\_edge}$(u,v,w,t)$, \texttt{get\_msf}$(t)$ \vfill
        \item \textbf{Time:} $\Oh(\sqrt{m}\log n)$ per operation \vfill
        \item \textbf{Space:} $\Theta(m\sqrt{m})$ \vfill
        \item \textbf{No fixed $m$ or time range restrictions} \vfill
        \end{itemize}
    \end{block}
    \note{
        - Summarize our main theoretical contribution
        - Emphasize that we don't need persistent data structures - this is the key advantage
        - Show we achieve the same time complexity as Demaine et al.: O(√m) per operation
        - Present our MSF implementation results: O(√m log n) per operation
        - Highlight that we removed the fixed m and time range restrictions
        - This demonstrates the practical value of our approach
        - Key insight: we provide a simpler alternative to persistent data structures
        - Space trade-off: Θ(m√m) vs O(m) - but much simpler implementation
        - Our approach is more practical for many applications
    }
\end{frame}

%-------------------------------------------------
% Extending for Full Retroactivity
%-------------------------------------------------
\begin{frame}
    \frametitle{Extending for full retroactivity}
    
    \begin{itemize}
    \item \textbf{General applicability:} Works for any partially retroactive data structure \vfill\pause
    \item \textbf{Supporting removals:} To achieve full retroactivity \vfill
        \begin{itemize}
        \item Adapt rebuilding trigger: when $|\lfloor\sqrt{m'}\rfloor - \lfloor\sqrt{m}\rfloor| \leq 1$
        \item Handle both insertions and removals in update sequence
        \item Rebuilding frequency: every $2\lfloor\sqrt{m}\rfloor-1$ operations
        \end{itemize} \vfill\pause
    \item \textbf{Requirements:}
        \begin{itemize}
        \item Partially retroactive data structure
        \item Rollback capability
        \item No persistent version needed
        \end{itemize} \vfill
    \end{itemize}
    \note{
        - Emphasize the general applicability of our approach
        - Explain how to extend for full retroactivity with removals
        - Show the adapted rebuilding trigger condition
        - Explain how to handle both insertions and removals
        - List the requirements: partially retroactive, rollback capability
        - This shows how our approach can be extended for full functionality
        - Key insight: our method works for any partially retroactive data structure
        - The rebuilding frequency changes but the core idea remains the same
        - This demonstrates the generality of our approach
    }
\end{frame}

%-------------------------------------------------
% SLIDE: Thank You
%-------------------------------------------------
\begin{frame}
    \begin{center}
        \Huge{Thank you! \\ \vfill Questions?}
    \end{center}
    \note{
        - Invite questions from the audience
        - Be prepared to answer questions about:
          * The rebuilding algorithm details
          * Space vs time trade-offs
          * Implementation challenges
          * Comparison with persistent data structures
          * Applications beyond MSF
        - Key points to emphasize if asked:
          * Our approach is simpler to implement
          * Same time complexity as Demaine et al.
          * No persistent data structure requirement
          * General applicability to any partially retroactive structure
        - Thank the audience for their attention
    }
\end{frame}

\end{document}