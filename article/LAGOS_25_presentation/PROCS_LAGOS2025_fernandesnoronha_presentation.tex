%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LaTeX Beamer Presentation (Condensed Version)
%
% On-s minimal.
% Speaker notes are included as comments (%) in each frame.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[fleqn]{beamer}

\usepackage[utf8]{inputenc}
\setlength{\mathindent}{\parindent}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx} 
\usepackage{pifont}
\usepackage{cancel}
\usepackage{tikz}
\usetikzlibrary{calc,positioning,decorations.pathmorphing,decorations.pathreplacing}
\usetikzlibrary{backgrounds}
\usepackage{pgfpages}
\usepackage{./figstyle}
\usepackage{algorithm}
\usepackage{algpseudocode}

\newcommand{\greencheck}{\textbf{\textcolor{green}{\ding{51}}}}
\newcommand{\Oh}{\mathcal{O}}

%------------------------------------------------------------
% Beamer notes
%------------------------------------------------------------
\setbeameroption{hide notes} % Only slides
% \setbeameroption{show only notes} % Only notes
% \setbeameroption{show notes on second screen=right} % Both

% Make notes font smaller to fit on page
\addtobeamertemplate{note page}{\begingroup\footnotesize}{\endgroup} % Wraps note page in smaller font

%------------------------------------------------------------
% Theme and Color Scheme
%------------------------------------------------------------
\usetheme{Boadilla}

\usecolortheme{default}

\pdfstringdefDisableCommands{%
  \def\\{}%
  \def\texttt#1{<#1>}%
  \def\vspace#1{}%
}

%------------------------------------------------------------
% Presentation Information
%------------------------------------------------------------
\title[Partial to full retroactivity]{How to go from partial to full retroactivity in detail}
\author[Felipe C. Noronha]{Cristina Gomes Fernandes, Felipe Castro de Noronha}
\institute[IME-USP]{
    IME-USP -- Brazil
}
\date{LAGOS 25 -- November 10-14, 2025}

%------------------------------------------------------------
% The Presentation Begins
%------------------------------------------------------------
\begin{document}

%-------------------------------------------------
% Title Page
%-------------------------------------------------
\begin{frame}
    \titlepage
    \note[item]{Hello everyone. My name is Felipe Noronha, and today I'll be presenting the work done by Professor Cristina Fernandes and I at IME-USP.}
    \note[item]{Our paper details a method for transforming partially retroactive data structures into fully retroactive ones.}
    \note[item]{This work is motivated by a practical limitation in the well-known 2007 transformation by Demaine, Iacono, and Langerman and it also builds upon a 2022 solution by Junior and Seabra.}
    \note[item]{Our key contribution is a method to achieve this transformation with the same time complexity, but *without* the need for complex persistent data structures.}
    \note[item]{To illustrate our approach, we'll use the minimum spanning forest problem as our main example. So, let's start by defining what that is.}
\end{frame}


%-------------------------------------------------
% What is a Spanning Tree?
%-------------------------------------------------
\begin{frame}
    \frametitle{What is a spanning tree?}
    
    \begin{itemize}
    \item Let $G = (V, E)$ be a connected graph \vfill
    \item \textbf{Spanning tree:} A tree with all vertices of $G$ \vfill\pause
    \item \textbf{Properties:}
        \begin{itemize}
        \item Connected (path between any two vertices)
        \item Acyclic (no cycles)
        \item Contains exactly $n-1$ edges for $n$ vertices
        \end{itemize} \vfill\pause
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Graph G edges (blue straight lines - edges NOT in T)
            \draw[blue, thick] (A) -- (B);  % AB
            \draw[blue, thick] (F) -- (G);  % FG
            \draw[blue, thick] (F) -- (D);  % FD
            \draw[blue, thick] (H) -- (D);  % HD  
            \draw[blue, thick] (C) -- (F);  % CF
            \draw[blue, thick] (G) -- (H);  % GH
            
            % Spanning tree T edges (red wavy lines)
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A);  % CA
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F);  % AF
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (D);  % AD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (D);  % GD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (D);  % BD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (E);  % BE
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (H) -- (E);  % HE
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {T};
        \end{tikzpicture}
        \caption{Graph $G$ (blue edges) and spanning tree $T$ (red wavy edges)}
    \end{figure}
    
    \note[item]{Lets start of by defining what is a spanning tree on a graph G with a set of vertices and edges}
    \note[item]{A spanning tree will be a tree will all the vertices of G}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{It will have 3 main properties: it is connected (path between any two vertices), acyclic (no cycles), contains exactly n-1 edges for n vertices}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Show visual example with graph G (blue edges) and spanning tree T (red wavy edges)}
    \note[item]{In the example: 8 vertices, so spanning tree has exactly 7 edges}
    \note[item]{Emphasize that spanning trees are not unique - there can be many valid spanning trees}    
\end{frame}


%-------------------------------------------------
% Minimum Spanning Tree and Forest
%-------------------------------------------------
\begin{frame}
    \frametitle{Minimum Spanning Tree and Forest}
    
    \begin{itemize}
    \item \textbf{Minimum Spanning Tree (MST):} spanning tree in a weighted graph with minimum total cost \vfill\pause
    \item \textbf{Minimum Spanning Forest (MSF):} generalization for disconnected graphs\pause \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Graph G edges (blue straight lines - edges NOT in MST)
            \draw[blue, thick] (A) -- (B) node[midway, above=0.1cm, font=\small] {8};  % AB
            \draw[blue, thick] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};  % FG
            \draw[blue, thick] (F) -- (D) node[midway, left=0.1cm, font=\small] {7};  % FD
            \draw[blue, thick] (H) -- (D) node[midway, right=0.1cm, font=\small] {9};  % HD  
            \draw[blue, thick] (C) -- (F) node[midway, left=0.1cm, font=\small] {5};  % CF
            \draw[blue, thick] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};  % GH
            
            % MST edges (red wavy lines) - with weights that make it minimum
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};  % CA
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};  % AF
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (D) node[midway, above=0.1cm, font=\small] {3};  % AD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (D) node[midway, right=0.1cm, font=\small] {2};  % GD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (D) node[midway, above=0.1cm, font=\small] {3};  % BD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (E) node[midway, right=0.1cm, font=\small] {1};  % BE
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (H) -- (E) node[midway, right=0.1cm, font=\small] {2};  % HE
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MST};
        \end{tikzpicture}
        \caption{Graph $G$ (blue edges) and Minimum Spanning Tree (red wavy edges)}
    \end{figure}

    \note[item]{Now, let's add weights or costs to the edges. In a weighted graph, a Minimum Spanning Tree, or MST, is a spanning tree that has the minimum possible total cost. It's an optimization problem.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{This concept generalizes to disconnected graphs as well. We call this a Minimum Spanning Forest, or MSF, which is simply the collection of MSTs for each connected component.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{In the visual example, you can see the same graph as before, but now with costs on the edges. The red edges again show the tree, but this time, they've been chosen to be the MST.}
    \note[item]{If we sum the costs of the red edges, we get a total of 14. Any other spanning tree you could build for this graph would have a total cost greater than or equal to 14.}
    \note[item]{This idea of maintaining an optimal-cost forest is central to our problem. Specifically, how to maintain this optimality as the graph changes.}
\end{frame}

%-------------------------------------------------
% Incremental MSF Problem
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF problem}
    
    \begin{itemize}
    \item \textbf{Problem:} Keep track of an MSF in a graph that grows over time \vfill
    \item Graph starts empty, edges are added one by one \vfill\pause
    \item \textbf{Operations:}
        \begin{itemize}
        \item \texttt{add\_edge}$(u,v,w)$: add edge with cost $w$ between vertices $u$ and $v$
        \item \texttt{get\_msf}(): return a list with the edges of an MSF of $G$
        \end{itemize} \vfill\pause
    \item \textbf{Solution:} Frederickson (1983) using link-cut trees \vfill
    \end{itemize}
    \note[item]{So, this brings us to the Incremental MSF problem. The goal is to maintain a Minimum Spanning Forest in a graph that grows over time.}
    \note[item]{Crucially, the graph starts empty, and edges are only added one by one.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{This problem is defined by two operations: $add\_edge$, which inserts a new weighted edge, and $get\_msf$, which returns the current minimum spanning forest.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{The solution to this was given by Frederickson in 1983. He used a dynamic data structure called link-cut trees which achieves a $O(\log n)$ amortized time per edge addition, where $n$ is the number of vertices.}
    % \note[item]{This incremental solution is the foundation for the *retroactive* version, which is what we're interested in.}
    % \note[item]{The key challenge will be adapting this to not only work for the *current* state, but for *any* time $t$ in the past.}
\end{frame}

%-------------------------------------------------
% Frederickson's Link-Cut Tree Solution
%-------------------------------------------------
\begin{frame}
    \frametitle{Frederickson's link-cut tree solution}
    
    \begin{itemize}
    \item \textbf{Key insight:} Use link-cut trees to maintain MSF dynamically \vfill\pause
    \item \textbf{Link-cut tree operations:}
        \begin{itemize}
        \item \texttt{find\_max}$(u,v)$: $\Oh(\log n)$ amortized
        \item \texttt{link}$(u,v,w)$: $\Oh(\log n)$ amortized
        \item \texttt{cut}$(u,v)$: $\Oh(\log n)$ amortized
        \end{itemize} \vfill\pause
    \item \textbf{Algorithm for adding edge $(u,v,w)$:}
        \begin{enumerate}
        \item Check if $u$ and $v$ are in same component
        \item If not: add edge to forest
        \item If yes: find max cost edge on $u$-$v$ path
        \item If $w < \text{max cost}$: replace max edge with new edge
        \end{enumerate} \vfill\pause
    \item \textbf{Total cost:} Amortized $\Oh(\log n)$ per edge addition \vfill
    \end{itemize}
    \note[item]{So, what was Frederickson's solution? He showed that link-cut trees can efficiently maintain this incrementing forest.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Link-cut trees provide all the operations we need, all in $O(\log n)$ amortized time: $find\_max$ to find the most expensive edge on a path, $link$ to add a weighted edge, and $cut$ to remove one.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{With this, we can construct a straightforward algorithm that supports adding a new edge $(u,v,w)$:}
    \note[item]{First, we check if $u$ and $v$ are already connected. If they're not, the new edge can't create a cycle, so we just add it to the forest using $link$.}
    \note[item]{If they *are* connected, adding this new edge creates a cycle. We find the most expensive edge on the path in that cycle using $find\_max$.}
    \note[item]{If our new edge's cost $w$ is cheaper than that maximum cost, we swap them: we $cut$ the old, expensive edge and $link$ our new, cheaper edge .}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{With these steps using LCT operations, the time per edge addition is $O(\log n)$ amortized.}
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 1
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 1}
    
    \begin{itemize}
    \item \textbf{add\_edge(g, h, 4):} Add edge with cost 4 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edge 1: G-H
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 1: Added edge (g,h) with cost 4}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h\} \vfill
    \end{itemize}
    \note[item]{Let's walk through a quick example. We start with an empty graph.}
    \note[item]{First, we add edge (g, h) with cost 4.}
    \note[item]{Are 'g' and 'h' connected? No. So, by step 2 of the algorithm, we simply add the edge to our MSF.}
    \note[item]{The MSF is now just \{g-h\}.}    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 2
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 2}
    
    \begin{itemize}
    \item \textbf{add\_edge(c, a, 1):} Add edge with cost 1 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edges 1-2
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 2: Added edge (c,a) with cost 1}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a\} \vfill
    \end{itemize}
    
    \note[item]{Next, we add (c, a) with cost 1.}
    \note[item]{Again, are 'c' and 'a' connected? No. They are in a different component from 'g' and 'h'.}
    \note[item]{So, we add it directly. The MSF now has two components: \{g-h\} and \{c-a\}.}    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 3
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 3}
    
    \begin{itemize}
    \item \textbf{add\_edge(f, g, 6):} Add edge with cost 6 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edges 1-3
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 3: Added edge (f,g) with cost 6}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g\} \vfill
    \end{itemize}

    \note[item]{Now, add (f, g) with cost 6.}
    \note[item]{Are 'f' and 'g' connected? No. 'f' is isolated, and 'g' is in the \{g-h\} component.}
    \note[item]{We link them. The MSF now contains \{c-a\} and \{f-g-h\}.}    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 4
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 4}
    
    \begin{itemize}
    \item \textbf{add\_edge(a, f, 2):} Add edge with cost 2 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edges 1-4
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 4: Added edge (a,f) with cost 2}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g, a-f\} \vfill
    \end{itemize}
    
    \note[item]{Add (a, f) with cost 2.}
    \note[item]{Are 'a' and 'f' connected? No. 'a' is in the \{c-a\} component and 'f' is in the \{f-g-h\} component.}
    \note[item]{We link these two components. Our forest now becomes a single tree, and all vertices shown so far are connected.}    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 5
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 5}
    
    \begin{itemize}
    \item \textbf{add\_edge(c, f, 5):} Add edge with cost 5 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edge NOT in MSF
            \draw[blue, thick] (C) -- (F) node[midway, above=0.1cm, font=\small] {5};  % CF

            % Edges 1-5
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 5: Added edge (c,f) with cost 5}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g, a-f\} \vfill
    \end{itemize}
    
    \note[item]{Okay, now we add (c, f) with cost 5. This is our first interesting case.}
    \note[item]{Are 'c' and 'f' connected? Yes, they are. Adding this edge will create a cycle: c-a-f-c.}
    \note[item]{So, we go to step 3. We find the max-cost edge on the path c-a-f. The edges are (c,a) with cost 1 and (a,f) with cost 2. The max cost is 2.}
    \note[item]{Our new edge costs 5. Since 5 is *not* less than the max cost of 2, we *do not* add this edge. It's discarded.}
    \note[item]{The MSF remains unchanged.}
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 6
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 6}
    
    \begin{itemize}
    \item \textbf{add\_edge(f, d, 7):} Add edge with cost 7 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Edge NOT in MSF
            \draw[blue, thick] (C) -- (F) node[midway, above=0.1cm, font=\small] {5};  % CF

            % Edges 1-6
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (D) node[midway, left=0.1cm, font=\small] {7};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 6: Added edge (f,d) with cost 7}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g, a-f, f-d\} \vfill
    \end{itemize}
    
    \note[item]{Next, add (f, d) with cost 7.}
    \note[item]{Are 'f' and 'd' connected? No. 'f' is in the main tree, but 'd' is a new, isolated vertex.}
    \note[item]{Therefore, we simply add the edge. The MSF is updated.}    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 7
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 7}
    
    \begin{itemize}
    \item \textbf{add\_edge(a, d, 3):} Add edge with cost 3 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};

            % Edge NOT in MSF
            \draw[blue, thick] (C) -- (F) node[midway, above=0.1cm, font=\small] {5};  % CF
            \draw[blue, thick] (F) -- (D) node[midway, above=0.1cm, font=\small] {7};  % FD
            
            % Edges 1-7
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (D) node[midway, left=0.1cm, font=\small] {3};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 7: Added edge (a,d) with cost 3}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, f-g, a-f, a-d\} \vfill
    \end{itemize}

    \note[item]{Now, add (a, d) with cost 3.}
    \note[item]{Are 'a' and 'd' connected? Yes. This creates the cycle a-f-d-a.}
    \note[item]{We find the max-cost edge on the path a-f-d. The edges are (a,f) with cost 2 and (f,d) with cost 7. The max cost is 7.}
    \note[item]{Our new edge costs 3. Since 3 *is* less than 7, we swap them.}
    \note[item]{We `cut` the expensive edge (f,d) and `link` our new, cheaper edge (a,d).}
    \note[item]{The MSF is now \{g-h, c-a, f-g, a-f, a-d\} and its total cost has improved.}    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Step 8
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Step 8}
    
    \begin{itemize}
    \item \textbf{add\_edge(d, g, 2):} Add edge with cost 2 \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};

            % Edge NOT in MSF
            \draw[blue, thick] (C) -- (F) node[midway, above=0.1cm, font=\small] {5};  % CF
            \draw[blue, thick] (F) -- (D) node[midway, above=0.1cm, font=\small] {7};  % FD
            \draw[blue, thick] (F) -- (G) node[midway, above=0.1cm, font=\small] {6};  % FG
            
            % Edges 1-7
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (D) -- (G) node[midway, right=0.1cm, font=\small] {2};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (D) node[midway, left=0.1cm, font=\small] {3};
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Step 8: Added edge (d,g) with cost 2}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{MSF:} \{g-h, c-a, a-f, a-d, d-g\} \vfill
    \end{itemize}
    
    \note[item]{Finally, let's add (d, g) with cost 2.}
    \note[item]{Are 'd' and 'g' connected? Yes. This creates the cycle d-a-f-g-d.}
    \note[item]{We find the max-cost edge on the path d-a-f-g. The edges are (d,a) cost 3, (a,f) cost 2, and (f,g) cost 6. The max cost is 6, from edge (f,g).}
    \note[item]{Our new edge costs 2. Since 2 *is* less than 6, we swap them.}
    \note[item]{We `cut` edge (f,g) and `link` our new edge (d,g).}
    \note[item]{The MSF is updated again, and the total cost is now 12.}    
\end{frame}

%-------------------------------------------------
% Incremental MSF Example - Final Result
%-------------------------------------------------
\begin{frame}
    \frametitle{Incremental MSF example - Final Result}
    
    \begin{itemize}
    \item \textbf{Continue adding edges...} \vfill\pause
    \item \textbf{Final MSF:} Minimum spanning forest with optimal cost \vfill
    \end{itemize}
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Define vertices in tree-like structure
            % Row 1: A B
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (A) at (0, 4) {a};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (B) at (4, 4) {b};
            
            % Row 2: C D E  
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (C) at (-2, 2) {c};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (D) at (2, 2) {d};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (E) at (6, 2) {e};
            
            % Row 3: F G H
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (F) at (0, 0) {f};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (G) at (2, 0) {g};
            \node[circle, draw, fill=blue!20, minimum size=0.6cm] (H) at (4, 0) {h};
            
            % Graph G edges (blue straight lines - edges NOT in MST)
            \draw[blue, thick] (A) -- (B) node[midway, above=0.1cm, font=\small] {8};  % AB
            \draw[blue, thick] (F) -- (G) node[midway, below=0.1cm, font=\small] {6};  % FG
            \draw[blue, thick] (F) -- (D) node[midway, left=0.1cm, font=\small] {7};  % FD
            \draw[blue, thick] (H) -- (D) node[midway, right=0.1cm, font=\small] {9};  % HD  
            \draw[blue, thick] (C) -- (F) node[midway, left=0.1cm, font=\small] {5};  % CF
            \draw[blue, thick] (G) -- (H) node[midway, below=0.1cm, font=\small] {4};  % GH
            
            % MST edges (red wavy lines) - with weights that make it minimum
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (C) -- (A) node[midway, left=0.1cm, font=\small] {1};  % CA
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (F) node[midway, left=0.1cm, font=\small] {2};  % AF
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (A) -- (D) node[midway, above=0.1cm, font=\small] {3};  % AD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (G) -- (D) node[midway, right=0.1cm, font=\small] {2};  % GD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (D) node[midway, above=0.1cm, font=\small] {3};  % BD
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (B) -- (E) node[midway, right=0.1cm, font=\small] {1};  % BE
            \draw[red, thick, decorate, decoration={snake, amplitude=1pt, segment length=8pt}] (H) -- (E) node[midway, right=0.1cm, font=\small] {2};  % HE
            
            % Labels
            \node[blue, font=\Large] at (-3, 2) {G};
            \node[red, font=\Large] at (7, 2) {\hspace{1em}MSF};
        \end{tikzpicture}
        \caption{Final MSF with optimal cost = 14}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{Solution:} Frederickson (1983) using link-cut trees \vfill
    \end{itemize}
    
    \note[item]{If we continue this process, adding all the remaining edges from our original graph...}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{...we would eventually arrive at the final, optimal Minimum Spanning Tree. The one shown here, for example, has a total cost of 12.}
    % \note[item]{So, to summarize, Frederickson's solution gives us an efficient $O(\log n)$ amortized time per *incremental* update.}
    % \note[item]{It perfectly handles cycle detection and edge replacement to maintain optimality.}
    \note[item]{But this only answers queries about the *present*. What if we want to ask: "What did the MSF look like 10 updates ago?"}
    \note[item]{This is the core question of retroactivity. How do we efficiently query the past?}    
\end{frame}

%-------------------------------------------------
% What is Retroactivity?
%-------------------------------------------------
\begin{frame}
    \frametitle{What is retroactivity?}
    
    \begin{itemize}
    \item \textbf{Problem:} Data structures usually support updates and queries \vfill
    \item The order of updates affects the state of the data structure \vfill\pause
    \item \textbf{Retroactivity:} Manipulate the sequence of updates \vfill\pause
    \item \textbf{Operations:}
        \begin{itemize}
        \item Insert update at time $t$ (possibly in the past)
        \item Remove update at time $t$
        \item Query at time $t$ (not just present)
        \end{itemize} \vfill
    \end{itemize}
    
    \note[item]{In a normal data structure, the order of updates is important. Most of the time, the state of the structure, and thus the answers to queries, depends on this sequence.}
    \note[item]{This means we usually don't have a good way to go back and correct mistakes or insert operations we forgot.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{That's where retroactivity comes in. A retroactive data structure allows us to manipulate this sequence of updates.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Specifically, it adds operations to: Insert a new update at some time $t$ *in the past*...}
    \note[item]{...Remove an update that *already happened* at time $t$....}
    \note[item]{...and, most importantly, Query the state of the structure at *any* time $t$, not just the present.}
    \note[item]{The key challenge is how to do this efficiently, maintaining the state for every possible time.}    
\end{frame}

%-------------------------------------------------
% Partial vs Full Retroactivity
%-------------------------------------------------
\begin{frame}
    \frametitle{Partial vs Full retroactivity}
    
    \begin{block}{Fully Retroactive}
        \begin{itemize}
        \item Queries at \textbf{any} time $t$
        \item Insert/remove updates at any time
        \end{itemize}
    \end{block} \pause

    \begin{block}{Partially Retroactive}
        \begin{itemize}
        \item Queries only on \textbf{current} state
        \item Insert/remove updates at any time
        \end{itemize}
    \end{block} \pause
    
    \begin{block}{Semi-Retroactive}
        \begin{itemize}
        \item Queries at \textbf{any} time $t$
        \item Insert updates at any time
        \item \textbf{No removal} of updates
        \end{itemize}
    \end{block}
    
    \note[item]{There are a few different "flavors" of retroactivity. The most powerful is Fully Retroactivity, which supports all the operations we just saw: insert, remove, and query, all at any time $t$.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Partially Retroactive is more limited. You can still insert or remove updates anywhere in the timeline, but you can only query the state of the structure at the *current* time, "now". This is a key limitation.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{And finally, there's Semi-Retroactive, which is a bit of a mix. You can query at any time $t$ and insert updates at any time, but you are *not allowed* to remove updates.}
    \note[item]{Generally, partially retroactive structures are much simpler to design. And this leads to an interesting challenge...}    
\end{frame}

%-------------------------------------------------
% The Challenge
%-------------------------------------------------
\begin{frame}
    \frametitle{The challenge}
    
    \begin{alertblock}{Challenge}
        How to transform partial $\rightarrow$ full retroactivity?
    \end{alertblock} \pause
    
    \begin{itemize}
    \item \textbf{Problem:} Need to support queries at any time $t$ \vfill
    \item \textbf{Solution approach:} Square-root decomposition \vfill\pause
    \item \textbf{Key insight:} Keep checkpoints with data structure states \vfill
    \item \textbf{Implementation:} Demaine, Iacono \& Langerman (2007) \vfill
    \end{itemize}
    
    \note[item]{...which is this: How can we transform a simple partially retroactive structure into a fully retroactive one?}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{We *have* a structure that lets us query "now", but we *need* a structure that lets us query any time $t$ in the past.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{A general solution for this was proposed by Demaine, Iacono, and Langerman in 2007.}
    \note[item]{Their approach uses a classic technique called square-root decomposition.}
    \note[item]{Let's see how that works.}    
\end{frame}

%-------------------------------------------------
% Demaine, Iacono & Langerman's Solution
%-------------------------------------------------
\begin{frame}
    \frametitle{Demaine, Iacono \& Langerman's solution}
    
    \begin{theorem}[Theorem 05]
        Any partially retroactive data structure can be transformed into a fully retroactive one with:
        \begin{itemize}
        \item $\Oh(\sqrt{m})$ slowdown per operation
        \item $\Oh(m)$ space usage
        \item \textbf{Requirement:} Need persistent version of the data structure
        \end{itemize}
    \end{theorem} \pause
    
    \begin{itemize}
    \item \textbf{Key idea:} Square-root decomposition \vfill
    \item Keep $\sqrt{m}$ checkpoints with data structure states \vfill\pause
    \item \textbf{Query at time $t$:}
        \begin{enumerate}
        \item Find closest checkpoint before $t$
        \item Apply updates from checkpoint to $t$
        \item Answer query, then rollback
        \end{enumerate} \vfill
    \end{itemize}
    
    \note[item]{Their paper presented this theorem: any partially retroactive data structure can be made fully retroactive.}
    \note[item]{The cost is an $O(\sqrt{m})$ slowdown per operation and $O(m)$ space, where $m$ is the number of updates.}
    \note[item]{But there's a catch: this transformation *requires* a persistent version of the data structure.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{So, how does it work? The idea is to break the $m$ updates into $\sqrt{m}$ blocks, each of size $\sqrt{m}$.}
    \note[item]{At the beginning of each block, we store a "checkpoint" of the data structure's state.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Now, to query at some time $t$:}
    \note[item]{First, we find the closest checkpoint *before* $t$. We load this saved state.}
    \note[item]{Then, we "roll forward" by applying all the updates between that checkpoint and time $t$. There are at most $\sqrt{m}$ of them.}
    \note[item]{We answer the query, and then we "roll back" the changes to restore the checkpoint, which is where persistence comes in handy.}
    \note[item]{This roll-forward and rollback gives us the $O(\sqrt{m})$ slowdown.}
    \note[item]{But this all hinges on having that persistent version for efficient checkpoints...}    
\end{frame}

%-------------------------------------------------
% The Space Problem
%-------------------------------------------------
\begin{frame}
    \frametitle{The space problem}
    
    \begin{itemize}
    \item \textbf{Naive approach:} Keep $\sqrt{m}$ independent copies \vfill
    \item Space usage: $\Theta(m\sqrt{m})$ \vfill\pause
    \item \textbf{Demaine et al. solution:} Use persistent data structures \vfill
    \item Space usage: $\Oh(m)$ \vfill\pause
    \end{itemize}
    
    \begin{alertblock}{Problem}
        What if we don't have or don't want to use persistent data structures?
    \end{alertblock} \pause
    
    \begin{block}{Our contribution}
        Simple rebuilding strategy without persistent data structures
        \begin{itemize}
        \item Same time complexity: $\Oh(\sqrt{m})$ per operation
        \item Space usage: $\Theta(m\sqrt{m})$
        \end{itemize}
    \end{block}
    
    \note[item]{...and that leads to the space problem. If we're naive and just store $\sqrt{m}$ *independent copies* of the data structure, one for each checkpoint...}
    \note[item]{...and each copy can have up to $m$ updates, our space usage explodes to $\Theta(m\sqrt{m})$.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{This is why Demaine et al. use persistent data structures. A persistent structure cleverly shares memory between versions, so all $\sqrt{m}$ checkpoints can be stored efficiently in just $O(m)$ total space.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{But this raises a practical problem: What if we don't have a persistent version of our data structure? Or what if it's just too complex to implement?}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{This is our contribution. We propose a simple rebuilding strategy that *doesn't* require persistence.}
    \note[item]{We achieve the *same $O(\sqrt{m})$ time* per operation.}
    \note[item]{The trade-off is that we go back to using $\Theta(m\sqrt{m})$ space, but we argue this is a practical trade-off for a much, much simpler implementation.}    
\end{frame}

%-------------------------------------------------
% Starting Point
%-------------------------------------------------
\begin{frame}
    \frametitle{Starting point}
    
    \begin{itemize}
    \item \textbf{Junior \& Seabra's solution:} Semi-retroactive incremental MSF \vfill
    \item \textbf{Operations:}
        \begin{itemize}
        \item \texttt{add\_edge}$(u,v,w,t)$: add edge at time $t$
        \item \texttt{get\_msf}$(t)$: get MSF at time $t$
        \end{itemize} \vfill\pause
    \item \textbf{Implementation:} Square-root decomposition \vfill
    \item \textbf{Checkpoints:} $t_i = i\sqrt{m}$ for $i = 1,\ldots,\sqrt{m}$ \vfill\pause
    \item \textbf{Data structures:} $D_i$ contains edges before time $t_i$ \vfill
    \item \textbf{Time:} $\Oh(\sqrt{m}\log n)$ per operation \vfill
    \end{itemize}
    
    \note[item]{Our starting point was the 2022 work by Junior and Seabra on a semi-retroactive MSF.}
    \note[item]{Remember, "semi-retroactive" means they can add edges at any time $t$ in the past, and query the MSF at any time $t$, but they cannot *remove* edges.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{They also use a square-root decomposition. They maintain $\sqrt{m}$ checkpoints, $t_i$, spaced $\sqrt{m}$ updates apart.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{They use a set of data structures, $D_i$, where each $D_i$ stores the incremental MSF containing all edges added *before* its checkpoint time $t_i$.}
    \note[item]{This approach gives them a final time complexity of $O(\sqrt{m} \log n)$ per operation.}
    \note[item]{However, their solution has some significant practical limitations...}    
\end{frame}

%-------------------------------------------------
% Limitations of Junior & Seabra
%-------------------------------------------------
\begin{frame}
    \frametitle{Limitations $\rightarrow$ Key Insight}

    \begin{alertblock}{Problems with the Existing Static Approach}
        \begin{itemize}
        \item \textbf{Fixed $m$:} Requires knowing the maximum sequence length ($\mathbf{m}$) beforehand. Meaning that it cannot handle arbitrary growth or dynamic operation counts.
        \end{itemize}
    \end{alertblock}

    \begin{block}{Our Dynamic Goal and Solution}
        \textbf{Goal:} Remove the $\mathbf{Fixed \ m}$ dependency while preserving time complexity.
        \begin{itemize}
            \item \textbf{Key Insight:} Introduce a **dynamic rebuilding process** to handle arbitrary growth. \vfill
            \item \textbf{Challenge:} Rebuilding $\mathbf{\sqrt{m}}$ checkpoints must be fast, avoiding complex persistent data structures. \vfill
            \item \textbf{Solution:} **Reuse** the existing data structures to efficiently reconstruct new checkpoints. \vfill
        \end{itemize}
    \end{block}

    \note[item]{The existing approach is based on a static constraint: we must assume a fixed $m$.}
    \note[item]{This means you have to know the total number of operations in advance.}
    \note[item]{Crucially, they lack a mechanism for **rebuilding**, making them unable to handle a growing or unknown number of operations.}
    \note[item]{Our goal is simple: remove the dependence on a fixed $m$ while keeping the time efficiency.}
    \note[item]{Our key insight is to introduce a **dynamic rebuilding process** to handle growth.}
    \note[item]{The challenge is doing this efficiently. Rebuilding $\sqrt{m}$ checkpoints non-persistently usually takes too long.}
    \note[item]{Our solution is a clever trick: we **reuse** the data structures already present in our system to reconstruct new checkpoints quickly.}
\end{frame}


%-------------------------------------------------
% Our Solution - Rebuilding Strategy
%-------------------------------------------------
\begin{frame}
    \frametitle{Our solution - Rebuilding strategy}
    
    \begin{itemize}
    \item \textbf{Key idea:} Reuse existing data structures during rebuilding \vfill
    \item \textbf{Rebuilding moments:} When $m = k^2$ (perfect square) \vfill\pause
    \item \textbf{Strategy:}
        \begin{enumerate}
        \item Create new empty structures $D'_0, D'_1$
        \item Reuse $D_i \rightarrow D'_{i+2}$ for $i = 0,\ldots,k-1$
        \item Apply missing updates to each $D'_i$
        \end{enumerate} \vfill\pause
    \end{itemize}
    
    \begin{block}{Key Lemma}
        Every update in $D_i$ is within the first $(i+2)(k+1)$ updates in the new sequence.
    \end{block} \pause
    
    \begin{itemize}
    \item \textbf{Time per rebuilding:} $\Oh(m\log n)$ \vfill
    \item \textbf{Amortized cost:} $\Oh(\sqrt{m}\log n)$ per operation \vfill
    \end{itemize}
    
    \note[item]{Here's our strategy. The key idea is to reuse the existing structures.}
    \note[item]{We trigger a rebuild whenever the total number of operations, $m$, becomes a perfect square, say $k^2$.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{When we rebuild, we're going from $k$ checkpoints to $k+1$ new ones. Our strategy is:}
    \note[item]{1. We create two new, *empty* structures, $D'_0$ and $D'_1$.}
    \note[item]{2. Then, we *reuse* our old structures: the old $D_0$ becomes the new $D'_2$, the old $D_1$ becomes the new $D'_3$, and so on. We shift them over by two spots.}
    \note[item]{3. Finally, we just apply the "missing" updates to each of these reused structures to get them up to date for their new checkpoint times.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{The reason this is efficient is based on a key lemma we prove: The updates needed for the new $D'_{i+2}$ are just a continuation of the updates from the old $D_i$. We don't have to restart from scratch.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{This rebuilding process takes $O(m \log n)$ time in total.}
    \note[item]{But since we only do it every $\sqrt{m}$ operations, the *amortized cost* per operation remains $O(\sqrt{m} \log n)$.}    
\end{frame}

%-------------------------------------------------
% Rebuilding Algorithm
%-------------------------------------------------
\begin{frame}
    \frametitle{Rebuilding algorithm}
    
    \begin{enumerate}
        \item $D'_0 \gets$ \textsc{newIncrementalMSF}()
        \item $D'_1 \gets$ \textsc{newIncrementalMSF}()
        \item For $i = 2$ to $k+1$: $D'_i \gets D_{i-2}$ \hfill {\footnotesize $\rhd$ reuse existing}
        \item For $i = 1$ to $k+1$:
        \begin{itemize}
        \item $p \gets$ \textsc{kth}$(S, i(k+1))$ \hfill {\footnotesize $\rhd$ $i(k+1)$th edge}
        \item $t'_i \gets p.\text{time}$
        \item \textsc{addEdges}$(S, t_{i-2}, t'_i, D'_i)$
        \end{itemize}
        \item Return $k+1, D', t'$
    \end{enumerate} \pause
    
    \begin{figure}
        \centering
        \begin{tikzpicture}[scale=0.8]
            % Original checkpoints
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D0) at (2, 2) {$D_0$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D1) at (4, 2) {$D_1$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D2) at (6, 2) {$D_2$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D3) at (8, 2) {$D_3$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D4) at (10, 2) {$D_4$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm] (D5) at (12, 2) {$D_5$};
            
            % New checkpoints
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=blue!20] (D0new) at (0, 0) {$D'_0$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=blue!20] (D1new) at (2, 0) {$D'_1$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D2new) at (4, 0) {$D'_2$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D3new) at (6, 0) {$D'_3$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D4new) at (8, 0) {$D'_4$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D5new) at (10, 0) {$D'_5$};
            \node[draw, rectangle, minimum width=1.5cm, minimum height=0.8cm, fill=green!20] (D6new) at (12, 0) {$D'_6$};
            
            % Arrows showing reuse
            \draw[->, thick, red] (D0.south) -- (D2new.north);
            \draw[->, thick, red] (D1.south) -- (D3new.north);
            \draw[->, thick, red] (D2.south) -- (D4new.north);
            \draw[->, thick, red] (D3.south) -- (D5new.north);
            \draw[->, thick, red] (D4.south) -- (D6new.north);
            
            % Labels
            \node at (0, 3) {\small Original};
            \node at (0, -1) {\small New};
            \node at (6, -1.5) {\small $D_i \rightarrow D'_{i+2}$};
        \end{tikzpicture}
        \caption{Rebuilding: Reuse existing data structures with offset}
    \end{figure}
    
    \begin{itemize}
    \item \textbf{Key insight:} Reuse $D_i \rightarrow D'_{i+2}$ \vfill
    \item \textbf{Time:} $\Oh(m\log n)$ total, $\Oh(\sqrt{m}\log n)$ amortized \vfill
    \item \textbf{Space:} $\Theta(m\sqrt{m})$ \vfill
    \end{itemize}
    
    \note[item]{This slide shows the algorithm in more detail.}
    \note[item]{Lines 1 and 2 create the two new empty structures, $D'_0$ and $D'_1$.}
    \note[item]{Line 3 is the reuse: we loop from $i=2$ up to $k+1$, and simply assign the old $D_{i-2}$ to be the new $D'_i$. This is just a pointer swap; it's instant.}
    \note[item]{Line 4 is where the work happens. We loop through our new structures and apply the missing updates to each one, from its old checkpoint time $t_{i-2}$ to its new checkpoint time $t'_i$.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{The diagram at the bottom visualizes this reuse. The new $D'_0$ and $D'_1$ are built from scratch, but all the others, $D'_2$ through $D'_{k+1}$, are just the old $D_0$ through $D_{k-1}$, shifted over and updated.}
    \note[item]{Again, this gives us the $O(\sqrt{m} \log n)$ amortized time...}
    \note[item]{...but it requires $\Theta(m \sqrt{m})$ space, because we are storing these $\sqrt{m}$ independent copies.}    
\end{frame}

%-------------------------------------------------
% Results
%-------------------------------------------------
\begin{frame}
    \frametitle{Results}
    
    \begin{block}{Our contribution}
        \begin{itemize}
        \item \textbf{General transformation:} Partial $\rightarrow$ Full retroactivity \vfill
        \item \textbf{No persistent data structures needed} \vfill
        \item \textbf{Same time complexity:} $\Oh(\sqrt{m})$ per operation \vfill
        \item \textbf{Space trade-off:} $\Theta(m\sqrt{m})$ vs $\Oh(m)$ \vfill
        \end{itemize}
    \end{block} \pause
    
    \begin{block}{Semi-retroactive MSF implementation}
        \begin{itemize}
        \item \textbf{Operations:} \texttt{add\_edge}$(u,v,w,t)$, \texttt{get\_msf}$(t)$ \vfill
        \item \textbf{Time:} $\Oh(\sqrt{m}\log n)$ per operation \vfill
        \item \textbf{Space:} $\Theta(m\sqrt{m})$ \vfill
        \item \textbf{No fixed $m$ or time range restrictions} \vfill
        \end{itemize}
    \end{block}
    
    \note[item]{So, to summarize our contributions:}
    \note[item]{We've developed a general transformation to take a partially retroactive data structure and make it fully retroactive.}
    \note[item]{Crucially, our method *does not require persistent data structures*.}
    \note[item]{We match the $O(\sqrt{m})$ slowdown per operation from the Demaine et al. paper...}
    \note[item]{...at the cost of $\Theta(m\sqrt{m})$ space, which we argue is a very practical trade-off for simplicity.}
    \note[item]{---------- SKIP SLIDE ----------}
    \note[item]{Applying this to our test case, we get a semi-retroactive MSF implementation.}
    \note[item]{It supports adding edges and querying the MSF at any time $t$ in $O(\sqrt{m} \log n)$ amortized time.}
    \note[item]{And, we have successfully removed the limitations from the previous work: our structure works *without* a fixed $m$ or a fixed time range.}    
\end{frame}

%-------------------------------------------------
% Extending for Full Retroactivity
%-------------------------------------------------
% \begin{frame}
%     \frametitle{Extending for full retroactivity}
    
%     \begin{itemize}
%     \item \textbf{General applicability:} Works for any partially retroactive data structure \vfill\pause
%     \item \textbf{Supporting removals:} To achieve full retroactivity \vfill
%         \begin{itemize}
%         \item Adapt rebuilding trigger: when $|\lfloor\sqrt{m'}\rfloor - \lfloor\sqrt{m}\rfloor| \leq 1$
%         \item Handle both insertions and removals in update sequence
%         \item Rebuilding frequency: every $2\lfloor\sqrt{m}\rfloor-1$ operations
%         \end{itemize} \vfill\pause
%     \item \textbf{Requirements:}
%         \begin{itemize}
%         \item Partially retroactive data structure
%         \item Rollback capability
%         \item No persistent version needed
%         \end{itemize} \vfill
%     \end{itemize}
    
%     \note[item]{Finally, while we focused on the semi-retroactive MSF, our transformation is general.}
%     \note[item]{---------- SKIP SLIDE ----------}
%     \note[item]{It can be extended to support *full* retroactivity, meaning it can handle *removals* of operations as well.}
%     \note[item]{To do this, we just adapt the rebuilding trigger. Instead of rebuilding only when $m$ grows, we rebuild whenever the *number of blocks* (the floor of $\sqrt{m}$) changes, whether from insertions or removals.}
%     \note[item]{This just means rebuilding happens a bit more frequently, but the amortized cost remains the same.}
%     \note[item]{---------- SKIP SLIDE ----------}
%     \note[item]{The only requirements for our transformation to work are:}
%     \note[item]{You must start with a partially retroactive data structure...}
%     \note[item]{...and it must have rollback capability, which the incremental MSF structure does.}
%     \note[item]{If you have those, you can use our method to make it fully retroactive *without* persistence.}    
% \end{frame}

%-------------------------------------------------
% SLIDE: Thank You
%-------------------------------------------------
\begin{frame}
    \begin{center}
        \Huge{Thank you! \ \vfill Questions?}
    \end{center}
    
    \note[item]{Invite questions from the audience}
    \note[item]{Be prepared to answer questions about:}
          \note[item]{* The rebuilding algorithm details}
          \note[item]{* Space vs time trade-offs}
          \note[item]{* Implementation challenges}
          \note[item]{* Comparison with persistent data structures}
          \note[item]{* Applications beyond MSF}
    \note[item]{Key points to emphasize if asked:}
          \note[item]{* Our approach is simpler to implement}
          \note[item]{* Same time complexity as Demaine et al.}
          \note[item]{* No persistent data structure requirement}
          \note[item]{* General applicability to any partially retroactive structure}
    \note[item]{Thank the audience for their attention}    
\end{frame}

\end{document}